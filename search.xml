<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbtMQ教程二</title>
      <link href="/2023/05/17/RabbtMQ%E6%95%99%E7%A8%8B%E4%BA%8C/"/>
      <url>/2023/05/17/RabbtMQ%E6%95%99%E7%A8%8B%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、发布确认"><a href="#一、发布确认" class="headerlink" title="一、发布确认"></a>一、发布确认</h2><p>​在前面我们通过将<strong>队列</strong>和<strong>消息</strong>持久化化操作，让消息保存在磁盘上。但是可能存在还没有保存磁盘上就出现宕机的情况。所以，我们需要继续第三步 <strong>发布确认</strong></p><p>​发布确认：生产者将消息发送给消费者，将消息保存在磁盘上后  ，MQ向生产者确认消息已经保存在磁盘上。 只有<strong>发布确认</strong>了后，才能保证消息的持久化。</p><h3 id="1-发布确认逻辑"><a href="#1-发布确认逻辑" class="headerlink" title="1. 发布确认逻辑"></a>1. 发布确认逻辑</h3><p>​生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>​confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h3 id="2-发布确认的策略（代码demo4）"><a href="#2-发布确认的策略（代码demo4）" class="headerlink" title="2. 发布确认的策略（代码demo4）"></a>2. 发布确认的策略（代码demo4）</h3><h4 id="2-1-开启发布确认的方法"><a href="#2-1-开启发布确认的方法" class="headerlink" title="2.1 开启发布确认的方法:"></a>2.1 开启发布确认的方法:</h4><p>​发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法 (在信道建立之后，消息发送之前，都可开启发布确认)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h4 id="2-2-单个确认发布"><a href="#2-2-单个确认发布" class="headerlink" title="2.2 单个确认发布"></a>2.2 单个确认发布</h4><p>​这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>​这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.单个确认发布</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-批量确认发布"><a href="#2-3-批量确认发布" class="headerlink" title="2.3 批量确认发布"></a>2.3 批量确认发布</h4><p>​上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.批量确认发布</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">       <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">       channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">       <span class="comment">//开启发布确认</span></span><br><span class="line">       channel.confirmSelect();</span><br><span class="line">       <span class="comment">//批量确认消息大小,每100次确认一次</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">       <span class="comment">//未确认消息个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">           channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">           outstandingMessageCount++;</span><br><span class="line">           <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">               channel.waitForConfirms();</span><br><span class="line">               outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">       <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           channel.waitForConfirms();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-异步确认发布"><a href="#2-4-异步确认发布" class="headerlink" title="2.4 异步确认发布"></a>2.4 异步确认发布</h4><p>​异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/14-40-39-5c3ff1cf0b6cd613b6d970152b261778-image-20230518144039536-8f5e12.png" alt="image-20230518144039536"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//3. 异步确认发布</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">         * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">         * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">         * 3.支持并发访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">         * 1.消息序列号</span></span><br><span class="line"><span class="comment">         * 2.是否为批量确认  true  可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment">         *                  false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            <span class="comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">            ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//清除该部分未确认消息</span></span><br><span class="line">            confirmed.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">            outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//消息确认失败 回调函数</span></span><br><span class="line">    <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;发布的消息&quot;</span> + message + <span class="string">&quot;未被确认，序列号&quot;</span> + sequenceNumber);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">         * 1.确认收到消息的回调（监听那些消息成功了）</span></span><br><span class="line"><span class="comment">         * 2.未收到消息的回调（监听那些消息失败了）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);<span class="comment">//异步通知</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * channel.getNextPublishSeqNo()获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">             * 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">             * 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-测试三种发布确认方式"><a href="#2-5-测试三种发布确认方式" class="headerlink" title="2.5 测试三种发布确认方式"></a>2.5 测试三种发布确认方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">      <span class="comment">//1.单个确认发布</span></span><br><span class="line">      ConfirmMessage.publishMessageIndividually(); <span class="comment">//发布1000个单独确认消息,耗时1172ms</span></span><br><span class="line">      <span class="comment">//2.批量确认发布</span></span><br><span class="line">      ConfirmMessage.publishMessageBatch();   <span class="comment">//发布1000个批量确认消息,耗时119ms</span></span><br><span class="line">      <span class="comment">//3.异步确认发布</span></span><br><span class="line">      ConfirmMessage.publishMessageAsync();   <span class="comment">//发布1000个异步确认消息,耗时49ms</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/14-38-44-0bc04a4acdfd902b4dadde5fdb18f910-image-20230518143844157-cedf3d.png" alt="image-20230518143844157"></p><p><strong>以上 3 种发布确认速度对比 :</strong></p><ul><li><p>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</p></li><li><p>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p></li><li><p>异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p></li></ul><p>到此，我们就学习了RabbitMQ的 <strong>简单模式</strong> 和 <strong>工作模式</strong> 。在交换机的学习中会学习到 <strong>发布、订阅模式</strong> 。</p><h2 id="二、交换机"><a href="#二、交换机" class="headerlink" title="二、交换机"></a>二、交换机</h2><p>​在之前的学习中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分的学习中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”。什么意思？就是我们通过将消息发送给交换机，然后交换机通过RoutingKey可以绑定多个队列，那每个队列都可以消费一次同一个消息（只是在同一个队列中同一消息不能被多次消费，但是在不同队列中可以）。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-09-54-0d5e0e86aab962e58ed047a90b78748f-image-20230518150954791-db4624.png" alt="image-20230518150954791"></p><h3 id="1-Exchanges"><a href="#1-Exchanges" class="headerlink" title="1. Exchanges"></a>1. Exchanges</h3><h4 id="1-1-Exchanges概念"><a href="#1-1-Exchanges概念" class="headerlink" title="1.1  Exchanges概念"></a>1.1  Exchanges概念</h4><blockquote><p>注意：在之前的学习中，我们并不是直接将消息发送给队列，二十使用了默认的交换机。</p></blockquote><p>​RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>​相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-18-15-4cf2bc006c5a9bdf3b049f4ab4437780-image-20230518151815403-1156f2.png" alt="image-20230518151815403"></p><h4 id="1-2-Exchanges类型"><a href="#1-2-Exchanges类型" class="headerlink" title="1.2  Exchanges类型"></a>1.2  Exchanges类型</h4><ul><li>直接(direct)</li><li>主题(topic) </li><li>标题(headers) </li><li>扇出(fanout)</li></ul><h4 id="1-3-无名exchange（默认交换机）"><a href="#1-3-无名exchange（默认交换机）" class="headerlink" title="1.3 无名exchange（默认交换机）"></a>1.3 无名exchange（默认交换机）</h4><p>​在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是<strong>默认交换机</strong>，我们通过空字符串(“”)进行标识。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-19-59-5aeeecab8a2b788df691c49eadeda9ce-RabbitMQ-00000036-44a981.png" alt="RabbitMQ-00000036"></p><p>​第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话。</p><h3 id="2-临时队列"><a href="#2-临时队列" class="headerlink" title="2. 临时队列"></a>2. 临时队列</h3><p>​之前的章节学习中使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p><p>​每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>创建临时队列的方式如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-29-18-f006c7bce4dc1eec2d88ba0823540fa5-image-20230518152917945-4fdaf4.png" alt="image-20230518152917945"></p><h3 id="3-绑定-bindings"><a href="#3-绑定-bindings" class="headerlink" title="3.  绑定 bindings"></a>3.  绑定 bindings</h3><p>​什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-30-35-221398f233a5e41e1e27fa339f156d9b-image-20230518153035165-0beb4d.png" alt="image-20230518153035165"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/18/15-30-45-0882e242e2061a7c8571056e3464134f-image-20230518153045695-7089fd.png" alt="image-20230518153045695"></p><h3 id="4-Fanout-exchange"><a href="#4-Fanout-exchange" class="headerlink" title="4. Fanout exchange"></a>4. Fanout exchange</h3><h4 id="4-1-Fanout-exchange（扇形交换机）介绍"><a href="#4-1-Fanout-exchange（扇形交换机）介绍" class="headerlink" title="4.1. Fanout  exchange（扇形交换机）介绍"></a>4.1. Fanout  exchange（扇形交换机）介绍</h4><blockquote><p>​在Fanout模式中，Exchange并不需要使用Routing Key。因为Fanout交换机将收到的消息广播到所有绑定到它的队列，而不管它们的Routing Key是什么。</p><p>​因此，在使用Fanout模式时，您只需创建一个Fanout Exchange，并将多个队列与此Exchange进行绑定即可。当发送消息时，它将通过Fanout交换机直接广播到所有已注册的队列上，而不会涉及关于消息路由的具体逻辑。这种设计使得Fanout模式的实现非常简单，而且能够高效地处理大量数据广播应用程序。</p></blockquote><p>​Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/19/17-13-11-60a3139a09a5012589c33e1a599173cf-image-20230519171311488-dab791.png" alt="image-20230519171311488"></p><h4 id="4-2-Fanout使用场景"><a href="#4-2-Fanout使用场景" class="headerlink" title="4.2 Fanout使用场景"></a>4.2 Fanout使用场景</h4><ul><li>在实时聊天应用程序中，当用户发送消息时，使用Fanout在订阅该频道的所有客户端之间广播该消息。</li><li>在多人协同编辑文档或平面设计的应用程序中，使用Fanout在编辑用户之间共享即时更新，并保持应用程序跟踪所有更改。</li><li>在在线多人游戏中，使用Fanout在玩家之间同步数据和当前状态。</li><li>在物联网应用中，从传感器设备获取数据后，使用Fanout将其广播到已注册该设备的所有相关应用程序及服务。</li><li>在大规模的分布式事件处理系统中，当发生事件时，使用Fanout在所有感兴趣的应用程序之间进行有效的发布和交换。</li></ul><h4 id="4-3-Fanout-实战-（代码demo5）"><a href="#4-3-Fanout-实战-（代码demo5）" class="headerlink" title="4.3 Fanout 实战 （代码demo5）"></a>4.3 Fanout 实战 （代码demo5）</h4><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/19/17-14-22-52d324472ebcbcf80b9cfcf77c637a41-image-20230519171422015-622314.png" alt="image-20230519171422015"></p><p>Logs 和临时队列的绑定关系如下图</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/19/17-15-39-04600ed2a0313cbe7284042b569e6a4e-image-20230519171539476-88e472.png" alt="image-20230519171539476"></p><p>​为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘。</p><p>（1）EmitLog 发送消息给两个消费者接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 声明一个 exchange</span></span><br><span class="line"><span class="comment">            * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">            * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）ReceiveLogs01 将接收到的消息打印在控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">        * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）ReceiveLogs02 将接收到的消息存储在磁盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">        * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试： </p><p>（1）生产者发出信息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/20-28-37-c17c80220ffd926456755f684f405aec-image-20230520202837693-1cda4e.png" alt="image-20230520202837693"></p><p>（2）消费者1接收到消息，打印在控制台</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/20-29-21-ceefe51464a2a3e545c86eb2700fd5ce-image-20230520202921216-fdfe55.png" alt="image-20230520202921216"></p><p>（3）消费者2接收到消息，将消息写入文件</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/20-30-01-5d4e2a064896fd65aaf559e477520d1e-image-20230520203001458-82c5fd.png" alt="image-20230520203001458"></p><h3 id="5-Direct-exchange"><a href="#5-Direct-exchange" class="headerlink" title="5. Direct exchange"></a>5. Direct exchange</h3><h4 id="5-1-回顾"><a href="#5-1-回顾" class="headerlink" title="5.1 回顾"></a>5.1 回顾</h4><p>​在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>​我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p><p>绑定之后的意义由其交换类型决定。</p><h4 id="5-2-Direct-exchange-（直连交换机）介绍"><a href="#5-2-Direct-exchange-（直连交换机）介绍" class="headerlink" title="5.2 Direct exchange （直连交换机）介绍"></a>5.2 Direct exchange （直连交换机）介绍</h4><p>​上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间。 Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的routingKey 队列中去。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/20-54-41-b076b54f0f41698cb765af44ca857827-image-20230520205441472-7ca41f.png" alt="image-20230520205441472"></p><p>​在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.</p><p>​在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 black green 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h4 id="5-3-Direct-Exchange使用场景"><a href="#5-3-Direct-Exchange使用场景" class="headerlink" title="5.3 Direct Exchange使用场景"></a>5.3 Direct Exchange使用场景</h4><p>​Direct Exchange（直连交换）是 RabbitMQ 提供的常用 Exchange 机制之一。它与其他类型的 Exchange 不同之处在于，Direct Exchange 会根据消息 routing key 直接将消息传递给 Binding key 匹配的队列，而不是通过特定的规则进行路由和过滤。</p><p>因此，当应用场景中需要精确指定消息的目标队列时，可以使用 Direct Exchange。例如：</p><ul><li>任务分发：系统中有多个任务消费者同盟，每个任务只能被一个消费者处理。这种情况下就可以使用 Direct Exchange 来指定任务对应的处理队列；</li><li>日志分类：将日志按照不同程度、类型或优先级分类存储到不同的队列中，可以使用Direct Exchange 将日志根据类型或关键字路由到不同的队列中去。这样既方便了后续的分析和监控，同时也有助于减少无关日志占用的存储资源。</li></ul><p>总之，如果需要按照固定的规则将消息路由到指定的队列中，可以选择使用 Direct Exchange。</p><h4 id="5-4-多重绑定"><a href="#5-4-多重绑定" class="headerlink" title="5.4 多重绑定"></a>5.4 多重绑定</h4><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-03-41-abf184ace221f86a6ca0aeda4a39d124-image-20230520210341278-995505.png" alt="image-20230520210341278"></p><p>​当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p><h4 id="5-5-Direct和Fanout的区别"><a href="#5-5-Direct和Fanout的区别" class="headerlink" title="5.5 Direct和Fanout的区别"></a>5.5 Direct和Fanout的区别</h4><p>Direct Exchange和Fanout Exchange是AMQP消息中间件中的两种常见Exchange类型，它们之间最显著的区别在于路由消息的方式。</p><p>​Direct Exchange是一种按照Routing Key精确匹配进行消息路由的Exchange类型。它通常会将通过Exchange发送到Queue的消息根据Routing Key值与绑定了该Routing Key的Queue进行匹配，并将消息路由到对应的Queue上。</p><p>​而Fanout Exchange是一种无条件广播所有消息到所有绑定队列的Exchange类型，不需要像Direct Exchange那样依赖Routing Key进行消息路由选择，只需要将消息“广播”到它所知道的所有队列上即可，每个队列都将接收到完全相同的消息。</p><p>​因此，两者的差异不仅在于Routing Key的使用，还在于Fanout Exchange更适用于广播发送给大量消费者的通信场景，而Direct Exchange则适合有选择性地将消息路由到一个或多个Queue的场景。</p><h4 id="5-5-Direct-实战（代码demo6）"><a href="#5-5-Direct-实战（代码demo6）" class="headerlink" title="5.5 Direct 实战（代码demo6）"></a>5.5 Direct 实战（代码demo6）</h4><p>关系：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-04-35-afb7d9b202b725e158736399a45715ec-image-20230520210435038-a4ea0e.png" alt="image-20230520210435038"></p><p>交换机：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-06-03-44f4b597e8eef55498d040ee62508912-image-20230520210603615-88fa55.png" alt="image-20230520210603615"></p><p>（1）消费者c1：绑定disk，routingKey为error</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">/**将交换机与队列绑定</span></span><br><span class="line"><span class="comment">         *  参数1：队列名称</span></span><br><span class="line"><span class="comment">         *  参数2：交换机名称</span></span><br><span class="line"><span class="comment">         *  参数3：RoutingKey名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="comment">//消息接收后回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message=<span class="string">&quot;接收绑定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\2023.02\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误日志已经接收&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息消费</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）消费者c2：绑定console，routingKey为info、warning</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//信道连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//交换机与队列绑定，但是绑定的RoutingKey有两个</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接 收 绑 定 键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）生产者：通过map来遍历得到routingKey和message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//创建多个 bindingKey</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line">        <span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>（1）生产者：发出四种类型的消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-55-03-1afea1f38a8f223c31c555c29003045d-image-20230520215503476-1b70e8.png" alt="image-20230520215503476"></p><p>（2）消费者c1：绑定disk，routingKey为error</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-56-02-1c16aef2781581f49709648100b38e10-image-20230520215602823-689936.png" alt="image-20230520215602823"></p><p>（3）消费者c2：绑定console，routingKey为info、warning</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/21-56-21-a1234e7fac25214483f16c0dbf1cd98d-image-20230520215621570-bbce03.png" alt="image-20230520215621570"></p><p>​因为没有消费这接收debug消息 所以debug消息就丢失了。</p><h3 id="6-Topics-Exchange"><a href="#6-Topics-Exchange" class="headerlink" title="6. Topics Exchange"></a>6. Topics Exchange</h3><h4 id="6-1-回顾"><a href="#6-1-回顾" class="headerlink" title="6.1 回顾"></a>6.1 回顾</h4><p>​在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</p><p>​尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型</p><h4 id="6-2-Topic-exchange（主题交换机）介绍"><a href="#6-2-Topic-exchange（主题交换机）介绍" class="headerlink" title="6.2 Topic exchange（主题交换机）介绍"></a>6.2 Topic exchange（主题交换机）介绍</h4><p>​Topic Exchange 根据通配符匹配规则将消息路由到一个或多个匹配的队列中去。初学新手一般都会用比较多的就是 Topic Exchange。这种类型的 Exchange 往往比较灵活，可以实现消息路由的更加细致和精准</p><h4 id="6-3-Topic的使用场景"><a href="#6-3-Topic的使用场景" class="headerlink" title="6.3 Topic的使用场景"></a>6.3 Topic的使用场景</h4><p>Topic Exchange（主题交换机）是 RabbitMQ 中非常常用的一种交换机类型，它根据自定义的 routing key 规则将消息路由到一个或多个匹配的队列中去，因此适合于以下场景：</p><ul><li>多级订阅者：Topic Exchange 允许使用模糊通配符来匹配 routing key。因此在实际应用中可以将前缀或后缀作为 routing key 的一部分，在订阅端采用通配符进行匹配，从而实现同一个 topic 下对不同层级、不同范围的消费者进行订阅。</li><li>发布与订阅：经过 Topic Exchange 再将消息发往相关的队列，通过这种方式实现了订阅系统的案例推送功能，而且可以灵活的定制订阅规则和过滤条件，从而能够更加方便地进行个性化推荐。</li><li>日志管理：例如针对日志系统收集各种类型、级别的日志信息，使用不同的 routing key 对应不同的 severity level 或应用程序名字，并绑定到各自的队列中，方便后续分类、存储和处理。</li></ul><p>​总之，当需要灵活地按照自定义的 routing key 匹配规则将消息路由到指定的队列中时，可以选择使用 Topic Exchange。</p><h4 id="6-3-Topic-的要求"><a href="#6-3-Topic-的要求" class="headerlink" title="6.3 Topic 的要求"></a>6.3 Topic 的要求</h4><p>​发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说： “stock.usd.nyse”,，”nyse.vmw”，”quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的</p><ul><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词</li></ul><h4 id="6-4-Topic-匹配案例"><a href="#6-4-Topic-匹配案例" class="headerlink" title="6.4 Topic 匹配案例"></a>6.4 Topic 匹配案例</h4><p>下图绑定关系如下</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/22-09-44-5b25c8b22136d32b2051d8dcb0f27910-image-20230520220943921-61d71a.png" alt="image-20230520220943921"></p><ul><li>Q1—&gt;绑定的是<ul><li>中间带 orange 带 3 个单词的字符串(<code>*.orange.*</code>)</li></ul></li><li>Q2—&gt;绑定的是<ul><li>最后一个单词是 rabbit 的 3 个单词(<code>*.*.rabbit</code>)</li><li>第一个单词是 lazy 的多个单词(lazy.#)</li></ul></li></ul><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><blockquote><p>注意：</p><ul><li>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了</li><li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</li></ul></blockquote><h4 id="6-5-Topic实战（代码demo7）"><a href="#6-5-Topic实战（代码demo7）" class="headerlink" title="6.5 Topic实战（代码demo7）"></a>6.5 Topic实战（代码demo7）</h4><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/22-13-02-ad63a0226268ec66950122df2fdfa883-image-20230520221302590-e7af1d.png" alt="image-20230520221302590"></p><p>（1）生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         * 中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         * 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）消费者C1：中间带 orange 带 3 个单词的字符串(<code>*.orange.*</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//声明 Q1 队列与绑定关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列 :&quot;</span> + queueName + <span class="string">&quot; 绑定 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）消费者C2：最后一个单词是 rabbit 的 3 个单词(<code>*.*.rabbit</code>)和第一个单词是 lazy 的多个单词(lazy.#)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//声明 Q2 队列与绑定关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列 :&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>（1）生产者发送消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/22-21-57-e5cc4119c94e99741fbf55687198d1c2-image-20230520222156912-ae0793.png" alt="image-20230520222156912"></p><p>（2）消费者C1接收 中间带 orange 带 3 个单词的字符串(<code>*.orange.*</code>)</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/22-22-56-7d4bad3f6fabcb85a07a806493f29176-image-20230520222256774-69384b.png" alt="image-20230520222256774"></p><p>（3）消费者C2接收 最后一个单词是 rabbit 的 3 个单词(<code>*.*.rabbit</code>)和第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/20/22-25-06-b8278ed0fa4faeda12c1f0d2a0ade259-image-20230520222505936-0f9f74.png" alt="image-20230520222505936"></p><h2 id="三、死信队列"><a href="#三、死信队列" class="headerlink" title="三、死信队列"></a>三、死信队列</h2><h3 id="1-死信队列的概念"><a href="#1-死信队列的概念" class="headerlink" title="1. 死信队列的概念"></a>1. 死信队列的概念</h3><p>​先从概念解释上搞清楚这个定义，死信，顾名思义就是<strong>无法被消费的消息</strong>，字面意思可以这样理解，一般来说， producer 将消息投递到 broker 或者直接到 queue 里了， consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><ul><li>为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中；还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</li><li>消息重试：在 RabbitMQ 中，当一个消息被拒绝或者处理失败时，可以将它发送到死信队列中并重新尝试处理。这种机制可以保证消息不会丢失，并且能够有效地避免因为某个消费者无法处理某些消息而导致整体系统出现问题。</li><li>消息延迟：RabbitMQ 支持对消息队列设置 TTL（Time To Live），当消息超过一定时间没有被消费者处理时，就会自动进入死信队列。这种机制可以实现消息的定时投递、过期删除以及异常处理等操作。</li><li>异常处理：在某些业务场景下，可能存在一些无法被消费者正常处理的消息，例如格式不正确的消息、包含敏感信息的消息等。通过将这些消息转发到死信队列中，可以便于后续进行人工处理和分析。</li></ul><h3 id="3-死信的来源"><a href="#3-死信的来源" class="headerlink" title="3. 死信的来源"></a>3. 死信的来源</h3><ul><li><p>消息 TTL 过期</p><p>TTL是Time To Live的缩写, 也就是生存时间</p></li><li><p>队列达到最大长度</p><p>队列满了，无法再添加数据到 mq 中</p></li><li><p>消息被拒绝</p><p>(basic.reject 或 basic.nack) 并且 requeue&#x3D;false.</p></li></ul><h3 id="4-死信实战"><a href="#4-死信实战" class="headerlink" title="4. 死信实战"></a>4. 死信实战</h3><h4 id="4-1-代码架构图"><a href="#4-1-代码架构图" class="headerlink" title="4.1 代码架构图"></a>4.1 代码架构图</h4><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/19-14-53-4ab76657c91915055615964697f04d6a-image-20230521191453712-e46470.png" alt="image-20230521191453712"></p><p>思路：生产者发送消息，通过直连交换机将消息发送到正常的队列(normal-queue)。若消息正常，则被消费者C1接收；若消息出现以下情况：</p><ul><li><p>消息 TTL 过期</p><p>TTL是Time To Live的缩写, 也就是生存时间</p></li><li><p>队列达到最大长度</p><p>队列满了，无法再添加数据到 mq 中</p></li><li><p>消息被拒绝</p><p>(basic.reject 或 basic.nack) 并且 requeue&#x3D;false.</p></li></ul><p>消息就会成为死信，然后被放入到死信队列，被消费者C2接收。</p><h4 id="4-2-消息-TTL-过期（代码demo8）"><a href="#4-2-消息-TTL-过期（代码demo8）" class="headerlink" title="4.2 消息 TTL 过期（代码demo8）"></a>4.2 消息 TTL 过期（代码demo8）</h4><h5 id="4-2-1-代码分析"><a href="#4-2-1-代码分析" class="headerlink" title="4.2.1 代码分析"></a>4.2.1 代码分析</h5><p>（1）在生产者中给消息设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties=<span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">               .builder()</span><br><span class="line">               .expiration(<span class="string">&quot;10000&quot;</span>)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure><p>然后通过for循环，模拟往队列中发送十条消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">           channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">           System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>拓展： AMQP.BasicProperties中的所有参数如下</p><ul><li>content_type：消息正文的 MIME 类型。通常可以设置成 JSON、XML、PLAIN_TEXT、BINARY 等格式。</li><li>content_encoding：消息正文编码格式。通常可以设置成 UTF-8、GBK、ISO-8859-1 等编码格式。</li><li>delivery_mode：消息投递模式。可选值包括 1 和 2，其中 1 表示消息非持久化，2 表示消息持久化。如果设置为 2，则消息会被写入磁盘中。</li><li>priority：消息优先级，取值范围为 0~9，值越大优先级越高。默认值为 0。</li><li>correlation_id：关联 ID，用于关联多个消息之间的关系。</li><li>reply_to：回复队列名字，表示需要返回处理结果的队列名称。</li><li>expiration：消息过期时间，单位为毫秒。</li><li>message_id：消息 ID，用于标识消息的唯一性。</li><li>timestamp：消息创建时间戳。</li><li>type：消息类型，用于区分不同类型的消息。例如，订阅主题模式时该值可以指定为 Topic。</li></ul><p>（2）消费者C1：</p><ul><li>首先，我们需要接收正常的消息，所以需要声明正常的队列和正常交换机。</li><li>其次，若消息异常，我们需要将消息发往死信队列，所以需要声明死信队列和死信交换机。</li><li>最后是将正常交换机与正常队列绑定，将死信队列和死信交换机绑定。</li></ul><p>代码的难度在于，如何在正常队列中设置死信交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueDeclare(String queue, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive, <span class="type">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span><br></pre></td></tr></table></figure><p>可以在声明队列函数的第五个参数里设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//过期时间 10000ms=10s   ,也可以在消费者发送时设置过期时间</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//正常队列设置死信交换机 //////////////////////////</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//设置死信交换机的routingKey</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br></pre></td></tr></table></figure><h5 id="4-2-2-代码"><a href="#4-2-2-代码" class="headerlink" title="4.2.2 代码"></a>4.2.2 代码</h5><p>（1）生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//设置消息的 TTL 时间</span></span><br><span class="line">        AMQP.BasicProperties properties=<span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder()</span><br><span class="line">                .expiration(<span class="string">&quot;10000&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）消费者C1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE=<span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信交换机和普通交换机 类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间 10000ms=10s   ,也可以在消费者发送时设置过期时间</span></span><br><span class="line"><span class="comment">//        arguments.put(&quot;x-message-ttl&quot;,10000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 //////////////////////////</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信交换机的routingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列 //////////////////////////</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将普通的交换机与普通的队列绑定</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhansan&quot;</span>);</span><br><span class="line">        <span class="comment">//将死信交换机与死信队列绑定</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息:&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）消费者C2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明队列与绑定关系</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收队列 :&quot;</span> + DEAD_QUEUE + <span class="string">&quot;,消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-3-测试"><a href="#4-2-3-测试" class="headerlink" title="4.2.3 测试"></a>4.2.3 测试</h5><p>（1）预期效果：我们先启动消费者C1，此时会声明正常队列和交换机、死信交换机和队列，然后将消费者C1关闭。启动生产者发送消息，这时没有消费者来接收消息，10S后消息过期，过期的消息将被添加到死信队列中，由消费者C2消费</p><p>（2）运行</p><p>启动消费者C1然后关闭</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-05-07-8d0a35fa3d50b131e1e46ebcd2bdc0e4-image-20230521210507130-148ec3.png" alt="image-20230521210507130"></p><p>此时队列已经声明</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-06-11-0ad05a7880f1bd776300130f679b33cc-image-20230521210611173-07981d.png" alt="image-20230521210611173"></p><p>启动生产者发送消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-07-00-e25b062a3b19c36b1b269e9a2bbbc57c-image-20230521210700519-8336ff.png" alt="image-20230521210700519"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-17-24-30cd472ce71f7c8c883992cca41a3e36-image-20230521211724259-a9bc08.png" alt="image-20230521211724259"></p><p>10S后</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-18-29-cce38c5311639586c91ae2848021724a-image-20230521211829314-f38621.png" alt="image-20230521211829314"></p><p>启动消费者C2</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-24-38-ffa11f03e22ce09b86467581b26b30c9-image-20230521212438889-073e79.png" alt="image-20230521212438889"></p><h4 id="4-3-队列达到最大长度（代码demo9）"><a href="#4-3-队列达到最大长度（代码demo9）" class="headerlink" title="4.3 队列达到最大长度（代码demo9）"></a>4.3 队列达到最大长度（代码demo9）</h4><h5 id="4-3-1-代码更改"><a href="#4-3-1-代码更改" class="headerlink" title="4.3.1 代码更改"></a>4.3.1 代码更改</h5><p>（1）消息生产者代码去掉 TTL 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息 )</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/21-58-17-c245f29e18bcec413bddd5a07bf27218-image-20230521215817461-5efa45.png" alt="image-20230521215817461"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置正常队列的长度限制 消息超过6条，超过的条数发送给死信队列</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>（3）C2 消费者代码不变</p><h5 id="4-3-2-测试"><a href="#4-3-2-测试" class="headerlink" title="4.3.2 测试"></a>4.3.2 测试</h5><p>（1）因为我们在消费者C1中添加了消息的长度设置，所以在测试之前，需要删除之前的队列重新启动消费者C1声明。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-03-53-e9a6888d4673499e63216922abbacb6a-image-20230521220353671-efb0b7.png" alt="image-20230521220353671"></p><p>（2）启动消费C1然后关闭，启动生产者发送消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-07-21-18b716991acb0aaf2483baf10dfb2c13-image-20230521220721130-1b7c67.png" alt="image-20230521220721130"></p><p>​由于正常队列中设置了最多存6条消息，所以发送的10条消息中，有4条消息在死信队列中。</p><h4 id="4-4-消息被拒绝"><a href="#4-4-消息被拒绝" class="headerlink" title="4.4 消息被拒绝"></a>4.4 消息被拒绝</h4><h5 id="4-4-1-代码更改（在demo9的基础上更改）"><a href="#4-4-1-代码更改（在demo9的基础上更改）" class="headerlink" title="4.4.1 代码更改（在demo9的基础上更改）"></a>4.4.1 代码更改（在demo9的基础上更改）</h5><p>（1）消息生产者代码同4.3生产者一致</p><p>（2）C3消费者代码(启动之后关闭该消费者 模拟其接收不到消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer3</span> &#123;</span><br><span class="line">    <span class="comment">//普通交换机的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE=<span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信交换机和普通交换机 类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信交换机的routingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将普通的交换机与普通的队列绑定</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//将死信交换机与死信队列绑定</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(<span class="string">&quot;info5&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer03 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer03 接收到消息&quot;</span> + message);</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息,要想拒绝消息，得开启手动应答 也就是  autoAck=false</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">false</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：channel.basicReject中各参数</p><ul><li>deliveryTag：标识符，用于表示当前处理的是哪一个消息。</li><li>requeue：是否需要重新入队列。如果为 true，则表示 RabbitMQ 会重新将这条消息放回从它原始队列中出发到此处(consumer)未发生拒绝确认的队尾；如果为 false，则表示直接丢弃掉该消息。</li></ul><p>​总之，channel.basicReject 方法用于将消息发送回 RabbitMQ 服务器以进行重新处理，并可通过 requeue 参数控制消息重新入队列还是直接丢弃。由于 requeue 参数可能会引起消息死循环等问题，因此应该慎重使用。通常情况下，我们建议使用 channel.basicNack 方法而非 channel.basicReject 方法来实现消息的拒绝确认功能。</p><h5 id="4-4-2-测试"><a href="#4-4-2-测试" class="headerlink" title="4.4.2 测试"></a>4.4.2 测试</h5><p>（1）在测试之前，先将之前队列中的数据清除（保持原始状态），因为将正常队列中消息的最大数量删除后，所以删除队列重新声明</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-26-29-0902e7a35888ebffda0e877c88da1981-image-20230521222629162-a52496.png" alt="image-20230521222629162"></p><p>（2）启动生产者发送消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-32-21-4608a617232dc1334ef66336d7427e20-image-20230521223220930-2750e6.png" alt="image-20230521223220930"></p><p>（3）启动消费者 C3。<img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-33-49-7deb39113ea8d7fff647a4a082fa9f1c-image-20230521223349303-6aff29.png" alt="image-20230521223349303"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-34-35-4c56bf1d7344aba31d07869005928d8d-image-20230521223435884-37672f.png" alt="image-20230521223435884"></p><p>消息info5被拒收，被发送给了死信队列，其余消息被正常消费。</p><p>（4）最后启动消费者C2，将死信队列中的info5消息消费。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/21/22-36-55-ae7e2db7299e6448707c5504859104ca-image-20230521223655765-a13151.png" alt="image-20230521223655765"></p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbtMQ教程一</title>
      <link href="/2023/05/09/RabbtMQ%E6%95%99%E7%A8%8B%E4%B8%80/"/>
      <url>/2023/05/09/RabbtMQ%E6%95%99%E7%A8%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MQ-的相关概念"><a href="#一、MQ-的相关概念" class="headerlink" title="一、MQ 的相关概念"></a>一、MQ 的相关概念</h2><h3 id="1-什么是MQ"><a href="#1-什么是MQ" class="headerlink" title="1. 什么是MQ"></a>1. 什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h3 id="2-为什么要用MQ"><a href="#2-为什么要用MQ" class="headerlink" title="2. 为什么要用MQ"></a>2. 为什么要用MQ</h3><ul><li><strong>流量消峰</strong></li></ul><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-36-29-59161dd5530dd5dcaa8fd6cfce8694db-1f684a91d6194500a95a1b5439f58e38-9904f0.png" alt="在这里插入图片描述"></p><ul><li><strong>应用解耦</strong></li></ul><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/19-54-56-b9e447f39d200b1f55917b4d1fcee50e-RabbitMQ-00000004-b33bdf.png" alt="RabbitMQ-00000004"></p><ul><li><strong>异步处理</strong></li></ul><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p><p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/19-54-56-8d9ce50390c044fb57669dd35beaba6b-RabbitMQ-00000005-726766.png" alt="RabbitMQ-00000005"></p><p>上面的说明不是很理解是吧，举个栗子：</p><p>场景说明：用户需发送短信验证码时，点击发送短信，第三方平台发送短信至用户手机成功，执行倒计时60秒。传统的做法有两种 1.串行的方式;2.并行方式：</p><p>(1) 串行方式：将用户点击发送短信，第三方平台发送短信至用户手机成功，执行倒计时60秒。以上三个任务全部完成后，返回给客户端(响应150ms)。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-29-49-1cb61a28a75a44625e1ac2c3d647387a-cbcb38b6ee390cae4c11acd7424cf18e-772c1d.png" alt="硬核！动力节点RabbitMQ入门教程，详细到哭"></p><p>(2) 并行方式：在用户点击发送短信成功后，第三方平台发送短信的同时，执行倒计时60秒。与串行的差别是，并行的方式可以提高处理的时间(响应100ms)。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-30-12-223cefb88f43036d26711081b1845ddf-2e32125351a8b343e1f9bfa807a07311-1c930a.png" alt="硬核！动力节点RabbitMQ入门教程，详细到哭"></p><p>(3) 引入消息队列，将不是必须的业务逻辑，异步处理(55ms)。改造后的架构如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-30-28-987aa61fa9fdd859fa582b95be669da4-8d0551dba2030c90c703591f085d904a-24e08d.png" alt="硬核！动力节点RabbitMQ入门教程，详细到哭"></p><p>为了更好的理解者三个特性:<a href="https://blog.csdn.net/Javanewspaper/article/details/122251486?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168414966416800215013095%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168414966416800215013095&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-122251486-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=rabbitmq%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">参考此链接</a></p><h3 id="3-MQ-的分类"><a href="#3-MQ-的分类" class="headerlink" title="3. MQ 的分类"></a>3. MQ 的分类</h3><p>::: tip ActiveMQ</p><p>:::</p><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><p>::: tip Kafka</p><p>:::</p><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点</strong>：性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</p><p><strong>缺点</strong>：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>；</p><p>::: tip RocketMQ</p><p>:::</p><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。</p><p>优点：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构，<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分 布式的，扩展性好,支<strong>持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p><p>缺点：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p><p>::: note RabbitMQ</p><p>:::</p><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，<strong>是当前最主流的消息中间件之一。</strong></p><p>优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 </p><p>官网更新：<a href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a></p><p>缺点：商业版需要收费,学习成本较高</p><h3 id="4-MQ-的选择"><a href="#4-MQ-的选择" class="headerlink" title="4. MQ 的选择"></a>4. MQ 的选择</h3><ul><li><strong>Kafka</strong></li></ul><p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p><p><a href="http://www.gulixueyuan.com/course/330/tasks">尚硅谷官网 kafka 视频教程</a></p><ul><li><strong>RocketMQ</strong></li></ul><p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><ul><li>RabbitMQ</li></ul><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h2><h3 id="1-RabbitMQ-的概念"><a href="#1-RabbitMQ-的概念" class="headerlink" title="1. RabbitMQ 的概念"></a>1. RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p><p>你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p><p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/19-54-57-0ff07c7857a14bd322fcf2d06c52637a-image-20210625230930992-eb718b.png" alt="image-20210625230930992"></p><p>官网：<a href="https://www.rabbitmq.com/#features">https://www.rabbitmq.com/#features</a></p><h3 id="2-四大核心概念"><a href="#2-四大核心概念" class="headerlink" title="2. 四大核心概念"></a>2. 四大核心概念</h3><ul><li><p>生产者</p><p>产生数据发送消息的程序是生产者</p></li><li><p>交换机</p><p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-37-29-1965e2cd79bd2783558a21b4ba8c6588-e1fb69fd30e942b2942b1e1b80ffe244-6c05bb.png" alt="在这里插入图片描述"></p><h3 id="3-RabbitMQ的核心部分"><a href="#3-RabbitMQ的核心部分" class="headerlink" title="3. RabbitMQ的核心部分"></a>3. RabbitMQ的核心部分</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-38-55-50caf5b30439a8ccabfdec2f2e3d4b88-ff99a7aa44b7476cbbc5a4b508605d1a-77fdfe.png" alt="在这里插入图片描述"></p><h3 id="4-各个名词介绍"><a href="#4-各个名词介绍" class="headerlink" title="4. 各个名词介绍"></a>4. 各个名词介绍</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/19-54-58-7ba1b021e027f130ef0de286cb0a7a55-RabbitMQ-00000007-47a19d.png" alt="RabbitMQ-00000007"></p><ul><li><p>Broker</p><p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p></li><li><p>Virtual host</p><p>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p>Connection</p><p>publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p>Channel</p><p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 </p></li><li><p>Exchange</p><p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p></li><li><p>Queue</p><p>消息最终被送到这里等待 consumer 取走</p></li><li><p>Binding</p><p>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><h2 id="三、RabbitMQ安装"><a href="#三、RabbitMQ安装" class="headerlink" title="三、RabbitMQ安装"></a>三、RabbitMQ安装</h2><h3 id="1-Linux环境下安装RabbitMQ"><a href="#1-Linux环境下安装RabbitMQ" class="headerlink" title="1.  Linux环境下安装RabbitMQ"></a>1.  Linux环境下安装RabbitMQ</h3><blockquote><p>我的安装参考：<a href="https://blog.csdn.net/m0_67392182/article/details/126040124">RabbitMQ安装教程</a> </p></blockquote><h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><p>官网下载地址：<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>这里我们选择的版本号（注意这两版本要求）</p><ul><li><p>rabbitmq-server-3.8.8-1.el7.noarch.rpm</p><p>GitHub：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8</a></p><p>加载下载：<a href="https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm">https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p></li><li><p>erlang-21.3.8.21-1.el7.x86_64.rpm</p><p>官网：<a href="https://www.erlang-solutions.com/downloads/">https://www.erlang-solutions.com/downloads/</a></p><p>加速：<a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm">https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm</a></p></li></ul><p>Red Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”</p><h4 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h4><p>上传到 <code>/usr/local/software</code> 目录下(如果没有 software 需要自己创建)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3 启动"></a>1.3 启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><h3 id="2-Web管理界面及授权操作"><a href="#2-Web管理界面及授权操作" class="headerlink" title="2. Web管理界面及授权操作"></a>2. Web管理界面及授权操作</h3><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><p>默认情况下，是没有安装web端的客户端插件，需要安装才可以生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><p>安装完毕以后，重启服务即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p>访问 <a href="http://42.192.149.71:15672/">http://42.192.149.71:15672</a> ，用默认账号密码(guest)登录，出现权限问题</p><p>默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户</p><h4 id="2-2-添加用户"><a href="#2-2-添加用户" class="headerlink" title="2.2 添加用户"></a>2.2 添加用户</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建账号和密码</span></span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为用户添加资源权限</span></span><br><span class="line"><span class="comment"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="comment"># 添加配置、写、读权限</span></span><br></pre></td></tr></table></figure><p>用户级别：</p><ol><li><strong>administrator</strong>：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理</li><li><strong>monitoring</strong>：监控者 登录控制台，查看所有信息</li><li><strong>policymaker</strong>：策略制定者 登录控制台，指定策略</li><li><strong>managment</strong>：普通管理员 登录控制台</li></ol><p>再次登录，用 admin 用户</p><p>::: tip 重置命令</p><p>:::</p><p>关闭应用的命令为：rabbitmqctl stop_app</p><p>清除的命令为：rabbitmqctl reset</p><p>重新启动命令为：rabbitmqctl start_app</p><p><strong>问题：</strong><a href="https://blog.csdn.net/weixin_44827844/article/details/115587788?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E5%BC%80%E5%90%AFrabbitMQ%EF%BC%8C%E5%9C%A8windows%E8%AE%BF%E9%97%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115587788.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">解决Linux中安装RabbitMQ后在windows无法打开15672和无法通过java发送消息</a></p><p>​(1) <strong>解决Linux中安装RabbitMQ后，无法在windows打开15672</strong></p><p>​首先，要确保自己的linux虚拟机已经安装部署好<a href="https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020">RabbitMQ</a>，并且在linux中能够访问15672端口</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/20-07-50-91692924eb5ab5ed2449a9a1eefb6823-20210411033040653-1a4062.png" alt="在这里插入图片描述"></p><p>​如图所示，我们在linux虚拟机中能够访问15672端口，但是windows中不能访问。</p><p>​<strong>(2) 打开Linux终端</strong></p><ol><li><p><strong>关闭firewall</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p><strong>禁止firewall开机启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/20-12-33-8beb198a242768e918bd6ec17e24f11b-image-20230509201233799-e58545.png" alt="image-20230509201233799"></p><p>之后再windos中就可以通过浏览器访问15672端口拉~  地址：<a href="http://192.168.32.128:15672/">http://192.168.32.128:15672/</a></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/20-15-46-4f08954d7f29a7f1338c42030a033b72-image-20230509201546520-45bddb.png" alt="image-20230509201546520"></p></li></ol><h2 id="四、Docker-安装"><a href="#四、Docker-安装" class="headerlink" title="四、Docker 安装"></a>四、Docker 安装</h2><p>官网：<a href="https://registry.hub.docker.com/_/rabbitmq/">https://registry.hub.docker.com/_/rabbitmq/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -<span class="built_in">id</span> --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management</span><br></pre></td></tr></table></figure><h2 id="五、HelloWorld"><a href="#五、HelloWorld" class="headerlink" title="五、HelloWorld"></a>五、HelloWorld</h2><h3 id="1-准备（代码demo1）"><a href="#1-准备（代码demo1）" class="headerlink" title="1. 准备（代码demo1）"></a>1. 准备（代码demo1）</h3><p>我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p><p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/20-54-57-6e24c8d5786bcae1a58cbd1600ce5ef1-RabbitMQ-00000012-b7a6a7.png" alt="RabbitMQ-00000012"></p><p>连接的时候，需要开启 5672 端口</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/20-54-57-6dc50b5ebbeb7d6e50d22fa6d0c3a99b-image-20210626162052259-efde46.png" alt="image-20210626162052259"></p><h3 id="2-新建项目导入依赖"><a href="#2-新建项目导入依赖" class="headerlink" title="2. 新建项目导入依赖"></a>2. 新建项目导入依赖</h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Producer消息生产者"><a href="#3-Producer消息生产者" class="headerlink" title="3. Producer消息生产者"></a>3. Producer消息生产者</h3><p>编码过程参考RabbitMQ工作原理图：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-00-36-9485f4e7fb4a1cca1026212a887eb349-image-20230509210036800-207b92.png" alt="image-20230509210036800"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/5/9 20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String queue_name=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//2、设置工厂ip,连接rabbitMQ队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.32.128&quot;</span>);</span><br><span class="line">        <span class="comment">//3、设置用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="comment">//4、设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;yu0804&quot;</span>);</span><br><span class="line">        <span class="comment">//5、创建连接</span></span><br><span class="line">        Connection connection=factory.newConnection();</span><br><span class="line">        <span class="comment">//6、获取信道</span></span><br><span class="line">        Channel channel=connection.createChannel();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    7、产生一个队列（因为只是一个小demo，所以省略了交换机）</span></span><br><span class="line"><span class="comment">     *      1.queue_name:队列名称</span></span><br><span class="line"><span class="comment">     *      2.队列里面的消息是否持久化 也就是是否用完就删除</span></span><br><span class="line"><span class="comment">     *      3.该队列是否只供一个消费者进行消费 是否进行共享; true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">     *      4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">     *      5.其他参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        channel.queueDeclare(queue_name,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//8、发送的消息内容</span></span><br><span class="line">        String message=<span class="string">&quot;Hello,world!&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        9、发送一个消息</span></span><br><span class="line"><span class="comment">     *      1.发送到那个交换机；所以省略了交换机</span></span><br><span class="line"><span class="comment">     *      2.路由的 key 是哪个 routingKey</span></span><br><span class="line"><span class="comment">     *      3.其他的参数信息</span></span><br><span class="line"><span class="comment">     *      4.发送消息的消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queue_name, <span class="literal">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：</p><p>（1）channel.queueDeclare中各参数</p><ul><li>queue：队列名字，用于指定要创建的队列名称。</li><li>durable：是否持久化。如果设置为 true，则表示队列是一个持久化队列，即使 RabbitMQ 服务器重启或者崩溃，该队列也不会丢失。如果设置为 false，则表示队列是一个非持久化队列，在 RabbitMQ 服务器重新启动或崩溃时会丢失。</li><li>exclusive：是否为私有队列。如果设置为 true，则表示该队列只能被当前连接使用，其他连接无法访问该队列。如果设置为 false，则表示允许多个连接共享该队列。</li><li>autoDelete：是否自动删除。如果设置为 true，则表示当队列没有被任何消费者使用时，该队列会自动被删除。如果设置为 false，则表示队列不会自动删除，除非调用了相关 API 进行删除操作。</li><li>arguments：一些额外的参数配置。例如，可以设置队列消息的 TTL、队列的最大长度等参数来影响队列的行为。</li></ul><p>（2）channel.basicPublish中各参数</p><ul><li>exchange：交换机名称，用于将消息路由到不同的队列中。如果使用默认的交换机，则可以将该值设置为空字符串（””）。</li><li>routingKey：路由键，表示消息被发送到哪一个队列中。如果 exchange 不为空，那么这个值就是和 exchange 绑定的 queue 的 binding key。如果 exchange 为空，则实际上使用的是默认的 exchange，路由键就代表具体的队列名称。</li><li>mandatory：如果为 true，则表示消息无法通过路由规则找到对应的情况下，会发送给 Basic.Return 方法。如果为 false，则表示如果找不到匹配的队列，则直接丢弃消息。</li><li>immediate：如果为 true，则表示消息需要立即发送给匹配的队列，而不能存储到未被匹配的队列缓存中。如果为 false，则表示消息会进入到相应的队列等待消费者来处理。</li><li>props：消息属性，用于设置 AMQP.BasicProperties 类对象相关的参数。具体包括 content_type、content_encoding、delivery_mode、priority、correlation_id、reply_to、expiration、message_id、timestamp 和 type 等属性参数。</li><li>body：消息正文，用于存储需要传递的数据信息。例如，JSON 格式的字符串或二进制格式的字节流都可以作为 body 参数进行传递。</li></ul><p> <strong>测试:</strong></p><p>（1）启动发送消息的main方法，可以在控制台中看到打印消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-12-50-8a80d78d9f9d246cdb6103ee7db7abbe-image-20230509211250322-c466c7.png" alt="image-20230509211250322"></p><p>（2）切换到浏览器RabbitMQ后台界面中，在”Queue”中可以看见”Hello”队列</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-17-29-14ea98475f7d9d39577031b7fcf11de5-image-20230509211729070-26653c.png" alt="image-20230509211729070"></p><p>(4) 点进队列中，可以看见一个消息在准备被消费，总共只有一个消息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-19-17-720383887a920703ad7cae3159319e42-image-20230509211917192-7904e8.png" alt="image-20230509211917192"></p><p>问题：报错  Caused by: com.rabbitmq.client.ShutdownSignalException: connection error; protocol method: #method&lt;connection.close&gt;(reply-code&#x3D;530, reply-text&#x3D;NOT_ALLOWED - access to vhost ‘&#x2F;‘ refused for user ‘yu’, class-id&#x3D;10, method-id&#x3D;40)</p><p><a href="https://blog.csdn.net/qq_45309297/article/details/106769303?ops_request_misc=&request_id=&biz_id=102&utm_term=Caused%20by:%20com.rabbitmq.client&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-106769303.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">解决方法</a></p><h3 id="4-Consumer消息消费者"><a href="#4-Consumer消息消费者" class="headerlink" title="4. Consumer消息消费者"></a>4. Consumer消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/5/9 21:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者：接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String queue_name=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;19.168.32.128&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;yu0804&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息 - 接受消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消息被取消时的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(queue_name, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：channel.basicConsume中各参数</p><ul><li>queue：队列名字，用于指定要订阅的队列名称。</li><li>autoAck：是否自动确认消息。如果设置为 true，则表示一旦收到该消息，RabbitMQ 服务器就会立即将该消息标记为已经被消费（从队列中删除）。如果设置为 false，则表示需要手动调用 channel.basicAck 方法来确认该消息。</li><li>consumerTag：用于标识该消费者，在取消订阅时需要使用到。</li><li>noLocal：不支持同一个连接中发送者和接收者使用同一个queueName；</li><li>exclusive：是否为私有队列。如果设置为 true，则表示该队列只能被当前连接使用，其他连接无法访问该队列。如果设置为 false，则表示允许多个连接共享该队列。</li><li>arguments：一些额外的参数配置。例如，可以设置队列消息的 TTL、队列的最大长度等参数来影响队列的行为。</li></ul><p>（1）DeliverCallback 是一个用于处理队列中投递的消息的回调函数。具体来说，当消费者成功的订阅了一个队列并准备接收其中的消息时，会通过 deliverCallback 回调函数返回收到的消息内容。通常可以将这个消息进行一些后续处理，例如保存到数据库或向特定的目的地址转发等。DeliverCallback 接口包含下面这个函数：</p><p>​void handle(String consumerTag, Delivery message) throws IOException;</p><p>其中，consumerTag 表示管道和消费者之间的标识 id，而 Delivery 对象则表示 RabbitMQ 返回给消费者的消息。使用 Delivery 对象可以获取到消息的内容、元数据以及重要的 header 信息。 而在 deliveryCallback 中实现的处理方式，可以与具体的应用场景密切相关。</p><p>（2）cancelCallback 是一个取消消费的回调函数，用于在 driven 模式下实现将消费者取消订阅特定队列的操作。当消费者通过调用 channel.basicCancel() 取消订阅时（或者发生一些其他错误导致消费者被强制关闭），RabbitMQ 就会执行 cancelCallback 函数来通知消费端已经取消订阅该队列。cancelCallback 接口包含如下方法：</p><p>​void handle(String consumerTag) throws IOException;</p><p>其中，consumerTag 表示管道和消费者之间的标识 id。在 handle 方法中可以实现对应的逻辑，例如释放相应资源、更新状态信息等。需要注意的是，如果消费者在处理消息时抛出异常，也会触发 cancelCallback 回调函数。</p><p><strong>测试：</strong></p><p>（1）启动接收消息的main方法，可以在控制台中看到打印消息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-40-35-5b023f72d1d2d50760af3ec4e880463b-image-20230509214035027-ee5f37.png" alt="image-20230509214035027"></p><p>（2）在RabbitMQ后台界面的Queue中可以看到消息被消费。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-41-54-f51530fbe3023ea89f7263a9d48b6b09-image-20230509214154427-586e53.png" alt="image-20230509214154427"></p><h2 id="六、Work-Queue"><a href="#六、Work-Queue" class="headerlink" title="六、Work Queue"></a>六、Work Queue</h2><p>Work Queue——工作队列(又称任务队列)，主要思想是避免立即执行资源密集型任务，而不得不等待他完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台执行的工作进程弹出任务并执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/21-57-30-fbb08a333df2db9f45598bdd24fdb51a-image-20230509215730457-5f01d2.png" alt="image-20230509215730457"></p><h3 id="1-轮训分发消息"><a href="#1-轮训分发消息" class="headerlink" title="1.  轮训分发消息"></a>1.  轮训分发消息</h3><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。</p><h4 id="1-1-抽取工具类（代码demo2）"><a href="#1-1-抽取工具类（代码demo2）" class="headerlink" title="1.1 抽取工具类（代码demo2）"></a>1.1 抽取工具类（代码demo2）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/5/9 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 连接工厂创建信道的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtil</span> &#123;</span><br><span class="line">    <span class="comment">//得到一个连接的Channel</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory=<span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//2、设置工厂ip,连接rabbitMQ队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.32.128&quot;</span>);</span><br><span class="line">        <span class="comment">//3、设置用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="comment">//4、设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;yu0804&quot;</span>);</span><br><span class="line">        <span class="comment">//5、创建连接</span></span><br><span class="line">        Connection connection=factory.newConnection();</span><br><span class="line">        <span class="comment">//6、获取信道</span></span><br><span class="line">        Channel channel=connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-启动两个工作线程来接受消息"><a href="#1-2-启动两个工作线程来接受消息" class="headerlink" title="1.2 启动两个工作线程来接受消息"></a>1.2 启动两个工作线程来接受消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/5/9 22:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 这是一个工作线程，是相当于一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息接受</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息被取消</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;C1 消费者启动等待消费.................. &quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了达到预期效果，我们必须要准备两个以上的工作线程，来体现每个线程之间是竞争关系，一个消息只能被消费一次。</p><p>(1) 先启动C1线程，在idea配置中勾选如下</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-22-09-8dfa2ebe9f42d39b20abf31d1c57992e-image-20230509222209782-7b84ef.png" alt="image-20230509222209782"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-24-01-d24c45b86784638637cb3e2fb75354fb-image-20230509222401677-881f14.png" alt="image-20230509222401677"></p><p>(2) 将C1改为C2，再次启动，此时就有两个线程了</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-25-11-65df7ce771731977e14c212f13c83786-image-20230509222511696-2e56c6.png" alt="image-20230509222511696"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-26-40-1ad2308ceda3cafcc1d30cbc49665881-image-20230509222640740-8d40c3.png" alt="image-20230509222640740"></p><p>（3）接着就是写一个生产者来发送大量发送消息，C1和C2轮询接收消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/5/9 20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者：发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTask</span> &#123;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息：参考rabbitMQ工作原理图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Channel channel= RabbitMQUtil.getChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、发送的消息内容</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> ((scanner.hasNext()))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 启动消息生产者发送消息，在控制台依次发送消息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-43-45-937e39e47b6eaa542b4c23330668c0ff-image-20230509224345773-461d4d.png" alt="image-20230509224345773"></p><p>观察C1线程和C2线程</p><p>C1：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-44-01-39541030b40e364e0e538b2432935b55-image-20230509224401289-4a56ec.png" alt="image-20230509224401289"></p><p>C2：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/09/22-44-14-47e7d91ebe9142a57d71750ac30b5f42-image-20230509224414733-c5ec8c.png" alt="image-20230509224414733"></p><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/10/10-30-50-80010347b319b6e66ba99a99ad8e0230-image-20230510103042964-e3bb12.png" alt="image-20230510103042964"></p><h2 id="七、消息应答"><a href="#七、消息应答" class="headerlink" title="七、消息应答"></a>七、消息应答</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了一部分，突然挂掉，会发生什么情况。RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有一个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为他无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息处理该消息之后，告诉rabbitMQ 他已经处理了，rabbitMQ就可以把该消息删除了。</strong></p><h3 id="2-自动应答"><a href="#2-自动应答" class="headerlink" title="2. 自动应答"></a>2. 自动应答</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/10/11-00-04-8f2a11dae0f0a30bb20514432eae93f3-10-59-57-8f2a11dae0f0a30bb20514432eae93f3-10-57-50-8f2a11dae0f0a30bb20514432eae93f3-image-20230510105749960-73a6c3-ea9f65-ec23e2.png"></p><p>在上述案例中，我们在消费中使用的是自动应答模式，在使用自动应答过程中会出现一些问题：</p><p>消息发送成功后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做到权衡</strong>。因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了。当然另一方面这种模式消费者那边可以传递过载消息，<strong>没有对传递者的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p><p>(很少使用，需要在良好环境的前提下使用。)</p><h3 id="3-手动应答的方式"><a href="#3-手动应答的方式" class="headerlink" title="3. 手动应答的方式"></a>3. 手动应答的方式</h3><ul><li><p>Channel.basicAck(用于肯定确认)</p><p>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p></li><li><p>Channel.basicNack(用于否定确认) </p></li><li><p>Channel.basicReject(用于否定确认)</p><p>与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</p></li></ul><p><strong>Multiple 的解释：</strong></p><p>手动应答的好处是可以批量应答并且减少网络拥堵 </p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/10/10-53-43-1f8f0da6e8b3c4e957a4fe09c8dfa4a4-image-20230510105343856-f2761b.png" alt="image-20230510105343856"></p><p>multiple 的 true 和 false 代表的不同含义：</p><ul><li>true 代表批量应答 channel 上未应答的消息。比如 channel 上传输有 tag 的消息 5,6,7,8。当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</li><li>false 同上面相比。只会应答 tag &#x3D; 8 的消息，5,6,7 这三个消息依然不会被确认收到消息应答。</li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-42-31-8c358b33ce1f78612f0a1c8ac37e5673-image-20230515194231687-480d15.png" alt="image-20230515194231687"></p><h3 id="4-消息自动重新入队"><a href="#4-消息自动重新入队" class="headerlink" title="4. 消息自动重新入队"></a>4. 消息自动重新入队</h3><p>如果消费者由于某些原因失去连接（其通道已经关闭，连接关闭或者TCP连接丢失），导致消息未发送ACK确认，RabbitMQj将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，他讲很快重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/19-47-37-0c408491c2b828381991ec688e71ea53-image-20230515194737737-dd7354.png" alt="image-20230515194737737"></p><h3 id="5-消息手动应答代码（代码demo3）"><a href="#5-消息手动应答代码（代码demo3）" class="headerlink" title="5. 消息手动应答代码（代码demo3）"></a>5. 消息手动应答代码（代码demo3）</h3><p>默认采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p><blockquote><p>代码预期效果：一个生产者，两个工作线程。模拟场景：将一个工作线程关闭(该线程并未执行完)，确保消息不能丢失，将消息放回对队列，被另外一个工作线程处理(重新消费）。</p></blockquote><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer3</span> &#123;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME=<span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息：参考rabbitMQ工作原理图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Channel channel= RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> ((scanner.hasNext()))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//发布消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程C1(消费者C1)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3Worker01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME=<span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Channel channel= RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息接受</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            SleepUtil.Sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息 false:表示不批量处理(批量应答可能出现消息丢失，最好是对消息处理一次应答一次)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息被取消</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 消费者启动等待消费.................. &quot;</span>);</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程C2(消费者C2)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3Worker02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME=<span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Channel channel= RabbitMQUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待消息处理时间较长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息接受</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡30 秒</span></span><br><span class="line">            SleepUtil.Sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息 false:表示不批量处理(批量应答可能出现消息丢失，最好是对消息处理一次应答一次)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息被取消</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;C2 消费者启动等待消费.................. &quot;</span>);</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出C1处理消息是比较快的(SleepUtil.Sleep(1))，C2处理消息很慢(SleepUtil.Sleep(10))，我们希望看到的是：C2处理过程中出现问题(比如宕机)，C1能继续处理C2未处理成功的消息(消息未被成功处理后被放回队列)。</p><p>测试：分别启动生产者和两个线程，生产者一次发出消息aa、bb、cc、dd；正常情况是C1和C2两个线程轮询处理消息，即：C1收到消息 aa、cc；C2收到消息 bb、dd。为了达到预期效果，我们在生产者发送第四次消息后关闭C2线程（10S内完成），这时mq将C2未处理的消息dd放回队列，让C1线程来处理，即：1收到消息 aa、cc、dd；C2只收到消息 bb。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/21-13-00-054f579d58fe53ea9564c7f354c39efe-image-20230515211300771-4feaa8.png" alt="image-20230515211300771"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/21-14-12-ecf94d800945870296f5cc9c10e9c724-image-20230515211412802-ecfa9c.png" alt="image-20230515211412802"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/15/21-15-32-76c13feeb9930af2b546198842ea9196-image-20230515211532374-2a1534.png" alt="image-20230515211532374"></p><h2 id="八、RabbitMQ-持久化"><a href="#八、RabbitMQ-持久化" class="headerlink" title="八、RabbitMQ 持久化"></a>八、RabbitMQ 持久化</h2><blockquote><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p></blockquote><h3 id="1-队列持久化"><a href="#1-队列持久化" class="headerlink" title="1. 队列持久化"></a>1. 队列持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让队列持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p></blockquote><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-08-33-b50627728f8f2b7393ed73a700a06409-image-20230517200833594-827c0c.png" alt="image-20230517200833594"></p><p>以下为控制台中持久化与非持久化队列的 UI 显示区、</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-08-48-50fb885a372f45e084d966093aa1ed40-image-20230517200848161-61ea1c.png" alt="image-20230517200848161"></p><h3 id="2-消息实现持久化"><a href="#2-消息实现持久化" class="headerlink" title="2.  消息实现持久化"></a>2.  消息实现持久化</h3><p>需要在消息<strong>生产者</strong>修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添加这个属性。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-09-47-8772f8dce8f08d6298623405ca0044fc-image-20230517200947912-911231.png" alt="image-20230517200947912"></p><p>将消息标记为持久化并不能<strong>完全保证不会丢失消息</strong>。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><p>如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p><h2 id="九、不公平分发"><a href="#九、不公平分发" class="headerlink" title="九、不公平分发"></a>九、不公平分发</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，<strong>在消费者中消费之前</strong>，我们可以设置参数 <code>channel.basicQos(1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"><span class="comment">//采用手动应答</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure><p>效果<img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-43-35-2168d84ee4e04b5d6e3eef042967c0c5-image-20230517204335332-66b833.png" alt="image-20230517204335332"><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-43-52-ec9693f511cc4dd9dc810c19d29d55f0-image-20230517204351927-534190.png" alt="image-20230517204351927"><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-44-02-b2bc8a4546dc6a345c395884ee894ca3-image-20230517204402145-f98064.png" alt="image-20230517204402145"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-12-13-d58a510084b6bba5bce900bc77eac2fe-image-20230517201212925-283f5e.png" alt="image-20230517201212925"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-12-37-39a74d4d9bc13a4f6b68cde344e7560f-20-12-31-39a74d4d9bc13a4f6b68cde344e7560f-image-20230517201231861-9e1d45-5e92ac.png"></p><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p><h2 id="十、预取值分发"><a href="#十、预取值分发" class="headerlink" title="十、预取值分发"></a>十、预取值分发</h2><p>带权的消息分发，如下图：生产者发送7条消息，我们希望消费者C1只接收2条，消费者C2接收5条。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-49-29-fdc3fdc69927978c59985088e35cb7b6-image-20230517204929339-7f10b1.png" alt="image-20230517204929339"></p><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高 向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/yuydot/Picture/2023/05/17/20-13-53-b21de99e7f9cb0c2bc9c2fdbe1b16bde-image-20230517201353182-df4fda.png" alt="image-20230517201353182"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不公平分发 prefetchCount=1</span></span><br><span class="line"><span class="comment">//预取值为2 prefetchCount=2</span></span><br><span class="line"><span class="comment">//预取值为5 prefetchCount=5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"><span class="comment">//采用手动应答</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶</title>
      <link href="/2023/05/06/MySQL%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/06/MySQL%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式缓存</title>
      <link href="/2023/05/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/2023/05/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单节点Reidis存在的问题：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/d9d92fcfc3884c7f87441b678ea3a003.png" alt="在这里插入图片描述"></p><h1 id="1、Redis的持久化"><a href="#1、Redis的持久化" class="headerlink" title="1、Redis的持久化"></a>1、Redis的持久化</h1><h2 id="1-1-Redis持久化"><a href="#1-1-Redis持久化" class="headerlink" title="1.1. Redis持久化"></a>1.1. Redis持久化</h2><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-2-RDB持久化"><a href="#1-2-RDB持久化" class="headerlink" title="1.2  RDB持久化"></a>1.2  <a href="https://so.csdn.net/so/search?q=RDB&spm=1001.2101.3001.7020">RDB</a>持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据</p><h3 id="1-2-1-执行时机"><a href="#1-2-1-执行时机" class="headerlink" title="1.2.1 执行时机"></a>1.2.1 执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p>(1) <strong>save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/d9acc91a3cfb4ae2b42ec536c51575fe.png" alt="在这里插入图片描述"></p><blockquote><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB&spm=1001.2101.3001.7020">数据迁移</a>时可能用到。</p></blockquote><p>(2) <strong>bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/3aa98fc8c8af4caa93dbceca13675ca6.png" alt="在这里插入图片描述"></p><blockquote><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p></blockquote><p>(3) <strong>停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/428f2b79f6ce42528dd431f09e61fbfa.png" alt="在这里插入图片描述"></p><p>(4) <strong>触发RDB条件</strong></p><p><strong>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span>  </span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span>  </span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> </span><br></pre></td></tr></table></figure><p><strong>RDB的其它配置也可以在redis.conf文件中设置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span> </span><br></pre></td></tr></table></figure><h3 id="1-2-2-RDB原理"><a href="#1-2-2-RDB原理" class="headerlink" title="1.2.2  RDB原理"></a>1.2.2  RDB原理</h3><p>bgsave开始时会fork主进程得到子进程&#x3D;&#x3D;（此过程是阻塞的）&#x3D;&#x3D;，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504171700075.png" alt="image-20230504171700075"></p><p>子进程拷贝父进程的页表，通过页表中与物理内存的映射关系来进行数据的读取和写入。</p><p>子进程写RDB文件的过程是异步的，若此时父进程进行写操作，同时子进程进行读操作时，读与写之间会产生冲突，可能会产生脏数据。为了避免这个问题的发生，fork底层会采用一种copy-on-wirte技术。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504172654928.png" alt="image-20230504172654928"></p><p>什么意思？在物理内存中，fork会把共享内存标记为只读模式，当主进程要写时，将数据拷贝一份，然后在对副本数据进程写操作，完成写操作后，读也只能在副本数据里面读了。</p><p>总结：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504173420534.png" alt="image-20230504173420534"></p><h3 id="1-2-3-RDB的缺点"><a href="#1-2-3-RDB的缺点" class="headerlink" title="1.2.3 RDB的缺点"></a>1.2.3 RDB的缺点</h3><ul><li><p>RDB执行间隔时间长，两次RDB之间写入数据有可能会丢失</p></li><li><p>fork子进程时时间长，会阻塞子进程</p></li><li><p>压缩，写出RDB文件比较耗时</p></li></ul><h2 id="1-3-AOF持久化"><a href="#1-3-AOF持久化" class="headerlink" title="1.3 AOF持久化"></a>1.3 AOF持久化</h2><h3 id="1-3-1-AOF原理"><a href="#1-3-1-AOF原理" class="headerlink" title="1.3.1 AOF原理"></a>1.3.1 AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><h3 id="1-3-2-AOF的配置"><a href="#1-3-2-AOF的配置" class="headerlink" title="1.3.2 AOF的配置"></a>1.3.2 AOF的配置</h3><p><strong>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p><strong>AOF的命令记录的频率也可以通过redis.conf文件来配：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">always</span> </span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> </span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/1af7719b47fc42e7bb31348fe82f3bb0.png"></p><h3 id="1-3-3-AOF文件重写"><a href="#1-3-3-AOF文件重写" class="headerlink" title="1.3.3 AOF文件重写"></a>1.3.3 AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504173743217.png" alt="image-20230504173743217"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/f9485a23a3bc42c592c3023bb0830e5c.png" alt="在这里插入图片描述"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。<br>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p><strong>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span> </span><br></pre></td></tr></table></figure><h2 id="1-4-RDB与AOF对比"><a href="#1-4-RDB与AOF对比" class="headerlink" title="1.4 RDB与AOF对比"></a>1.4 RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/312741bafa9a43b38e83eb50bf8f2e12.png" alt="在这里插入图片描述"></p><h1 id="2、Redis主从架构"><a href="#2、Redis主从架构" class="headerlink" title="2、Redis主从架构"></a>2、Redis主从架构</h1><h2 id="2-1-搭建主从架构"><a href="#2-1-搭建主从架构" class="headerlink" title="2.1 搭建主从架构"></a>2.1 搭建主从架构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/9c46bfe19b6b4ff4a03504c449f5834f.png" alt="在这里插入图片描述"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>192.168.56.10</td><td>7001</td><td>master</td></tr><tr><td>192.168.56.10</td><td>7002</td><td>slave</td></tr><tr><td>192.168.56.10</td><td>7003</td><td>slave</td></tr></tbody></table><p>(1) 创建目录</p><p>我们创建三个文件夹，名字分别叫redis7001、redis7002、redis7003：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /mysoft</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir redis7001 redis7002 redis7003</span><br></pre></td></tr></table></figure><p>(2) 恢复原始配置</p><p>修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的<strong>RDB模式</strong>，AOF保持关闭状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启RDB</span></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="string">save</span> <span class="number">3600 </span><span class="number">1</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">100</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭AOF</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) 拷贝redis-6.2.4&#x2F;redis.conf文件到每个实例目录</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/978036d84b864d2dbe526bd7a8a480da.png" alt="在这里插入图片描述"></p><p>(4) 修改每个实例的端口、工作目录</p><p>redis7001中的 redis.conf 将端口改为7001 ， dir &#x3D; &#x2F;mysoft&#x2F;redis7001 (保存rdb文件的目录)</p><p>(5) 修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis实例的声明 IP</span></span><br><span class="line"><span class="string">replica-announce-ip</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p>(6) 启动三个实例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line"><span class="string">redis-server</span> <span class="string">redis7001/redis.conf</span></span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line"><span class="string">redis-server</span> <span class="string">redis7002/redis.conf</span></span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line"><span class="string">redis-server</span> <span class="string">redis7003/redis.conf</span></span><br></pre></td></tr></table></figure><p>(7) 开启主从关系</p><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。<br>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：slaveof <masterip> <masterport></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><ul><li><pre><code>slaveof &lt;masterip&gt; &lt;masterport&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过redis-cli命令连接7002，执行下面命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h1 id="连接-7002"><a href="#连接-7002" class="headerlink" title="连接 7002"></a>连接 7002</h1><p>redis-cli -p 7002</p><h1 id="执行slaveof-x3D-》-7002实例是7001的从节点"><a href="#执行slaveof-x3D-》-7002实例是7001的从节点" class="headerlink" title="执行slaveof &#x3D;》 7002实例是7001的从节点"></a>执行slaveof &#x3D;》 7002实例是7001的从节点</h1><p>slaveof 192.168.56.10 7001</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过redis-cli命令连接7003，执行下面命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="连接-7003"><a href="#连接-7003" class="headerlink" title="连接 7003"></a>连接 7003</h1><p>redis-cli -p 7003<br>执行slaveof &#x3D;》 7003实例是7001的从节点<br>slaveof 192.168.56.10 7001</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后连接 7001节点，查看集群状态：</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="连接-7001"><a href="#连接-7001" class="headerlink" title="连接 7001"></a>连接 7001</h1><p>redis-cli -p 7001</p><h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><p>info replication</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/85792e1c971e43ea92ffa2a0db7c5630.png)</span><br><span class="line"></span><br><span class="line">(7)测试</span><br><span class="line"></span><br><span class="line">至此，redis主从架构搭建完毕</span><br><span class="line">主节点上可以写入数据，从节点数据只读</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2.2 主从架构中数据同步的原理</span><br><span class="line"></span><br><span class="line">(1) 全量同步</span><br><span class="line"></span><br><span class="line">主从第一次建立连接时，会执行**全量同步**，将master节点的所有数据都拷贝给slave节点，流程：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/38b576d0266e412f870f40ac826ae727.png)</span><br><span class="line"></span><br><span class="line">master如何得知salve是第一次来连接呢？？</span><br><span class="line"></span><br><span class="line">- **Replication Id**：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的**replid**，slave则会继承master节点的**replid**</span><br><span class="line">- **offset**：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</span><br><span class="line"></span><br><span class="line">因此slave做数据同步，必须向master声明自己的**replication id** 和**offset**，master才可以判断到底需要同步哪些数据。</span><br><span class="line"></span><br><span class="line">因为slave原本也是一个master，有自己的**replid**和**offset**，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的**replid**和**offset**。</span><br><span class="line">master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</span><br><span class="line">master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</span><br><span class="line">因此，**master判断一个节点是否是第一次同步的依据，就是看replid是否一致。**</span><br><span class="line">![在这里插入图片描述](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6eff3ea7784c4772bee193ea9cf31826.png)</span><br><span class="line"></span><br><span class="line">完整流程描述：</span><br><span class="line"></span><br><span class="line">- slave节点请求增量同步</span><br><span class="line">- master节点判断**replid**，发现不一致，拒绝增量同步</span><br><span class="line">- master将完整内存数据生成RDB，发送RDB到slave</span><br><span class="line">- slave清空本地数据，加载master的RDB</span><br><span class="line">- master将RDB期间的命令记录在**repl_baklog**，并持续将log中的命令发送给slave</span><br><span class="line">- slave执行接收到的命令，保持与master之间的同步</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(2) 增量同步</span><br><span class="line"></span><br><span class="line">全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做**增量同步**。</span><br><span class="line"></span><br><span class="line">什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6e736862003f4d15af0274d42aa5d1c7.png)</span><br><span class="line"></span><br><span class="line">那么`master`怎么知道`slave`与自己的数据差异在哪里呢? 继续往下看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3) repl_backlog原理</span><br><span class="line"></span><br><span class="line">**repl_backlog本质是类似一个圆形内存缓冲区数组**</span><br><span class="line"></span><br><span class="line">master怎么知道slave与自己的数据差异在哪里呢?</span><br><span class="line"></span><br><span class="line">这就要说到全量同步时的**repl_baklog**文件了。</span><br><span class="line"></span><br><span class="line">这个文件是一个固定大小的数组，只不过数组是环形，也就是说角标到达数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。</span><br><span class="line"></span><br><span class="line">**repl_baklog**中会记录Redis处理过的命令日志及**offset**，包括**master**当前的**offset**，和**slave**已经拷贝到的**offset**：</span><br><span class="line">![image-20230504212345032](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212345032.png)</span><br><span class="line"></span><br><span class="line">slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</span><br><span class="line"></span><br><span class="line">随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</span><br><span class="line"></span><br><span class="line">![image-20230504212356167](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212356167.png)</span><br><span class="line"></span><br><span class="line">直到数组被填满：</span><br><span class="line"></span><br><span class="line">![image-20230504212406766](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212406766.png)</span><br><span class="line"></span><br><span class="line">此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</span><br><span class="line"></span><br><span class="line">但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</span><br><span class="line"></span><br><span class="line">![image-20230504212416718](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212416718.png)</span><br><span class="line"></span><br><span class="line">如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</span><br><span class="line"></span><br><span class="line">![image-20230504212426817](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212426817.png)</span><br><span class="line"></span><br><span class="line">棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</span><br><span class="line"></span><br><span class="line">![image-20230504212436408](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212436408.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2.3.主从同步优化</span><br><span class="line"></span><br><span class="line">主从同步可以保证主从数据的一致性，非常重要。</span><br><span class="line"></span><br><span class="line">可以从以下几个方面来优化Redis主从就集群：</span><br><span class="line"></span><br><span class="line">- 在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</span><br><span class="line">- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</span><br><span class="line">- 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</span><br><span class="line">- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</span><br><span class="line"></span><br><span class="line">主从从架构图：</span><br><span class="line"></span><br><span class="line">![image-20230504212523965](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212523965.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2.4.小结</span><br><span class="line"></span><br><span class="line">简述全量同步和增量同步区别？</span><br><span class="line"></span><br><span class="line">- 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</span><br><span class="line">- 增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</span><br><span class="line"></span><br><span class="line">什么时候执行全量同步？</span><br><span class="line"></span><br><span class="line">- slave节点第一次连接master节点时</span><br><span class="line">- slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</span><br><span class="line"></span><br><span class="line">什么时候执行增量同步？</span><br><span class="line"></span><br><span class="line">- slave节点断开又恢复，并且在repl_baklog中能找到offset时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.Redis哨兵</span><br><span class="line"></span><br><span class="line">Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</span><br><span class="line"></span><br><span class="line">## 3.1.哨兵原理</span><br><span class="line"></span><br><span class="line">### 3.1.1.集群结构和作用</span><br><span class="line"></span><br><span class="line">哨兵的结构如图：</span><br><span class="line"></span><br><span class="line">![image-20230504212608418](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212608418.png)</span><br><span class="line"></span><br><span class="line">哨兵的作用如下：</span><br><span class="line"></span><br><span class="line">- **监控**：Sentinel 会不断检查您的master和slave是否按预期工作</span><br><span class="line">- **自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</span><br><span class="line">- **通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.1.2.集群监控原理</span><br><span class="line"></span><br><span class="line">Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</span><br><span class="line"></span><br><span class="line">•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。</span><br><span class="line"></span><br><span class="line">•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。</span><br><span class="line"></span><br><span class="line">![image-20230504212620660](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212620660.png)</span><br><span class="line"></span><br><span class="line">### 3.1.3.集群故障恢复原理</span><br><span class="line"></span><br><span class="line">一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</span><br><span class="line"></span><br><span class="line">- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</span><br><span class="line">- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</span><br><span class="line">- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</span><br><span class="line">- 最后是判断slave节点的运行id大小，越小优先级越高。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当选出一个新的master后，该如何实现切换呢？</span><br><span class="line"></span><br><span class="line">流程如下：</span><br><span class="line"></span><br><span class="line">- sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</span><br><span class="line">- sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</span><br><span class="line">- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</span><br><span class="line"></span><br><span class="line">![image-20230504212634089](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212634089.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.1.4.小结</span><br><span class="line"></span><br><span class="line">Sentinel的三个作用是什么？</span><br><span class="line"></span><br><span class="line">- 监控</span><br><span class="line">- 故障转移</span><br><span class="line">- 通知</span><br><span class="line"></span><br><span class="line">Sentinel如何判断一个redis实例是否健康？</span><br><span class="line"></span><br><span class="line">- 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</span><br><span class="line">- 如果大多数sentinel都认为实例主观下线，则判定服务下线</span><br><span class="line"></span><br><span class="line">故障转移步骤有哪些？</span><br><span class="line"></span><br><span class="line">- 首先选定一个slave作为新的master，执行slaveof no one</span><br><span class="line">- 然后让所有节点都执行slaveof 新master</span><br><span class="line">- 修改故障节点配置，添加slaveof 新master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3.2.搭建哨兵集群</span><br><span class="line"></span><br><span class="line">具体搭建流程参考课前资料《Redis集群.md》：</span><br><span class="line"></span><br><span class="line">![image-20230504212654429](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212654429.png)</span><br><span class="line"></span><br><span class="line">## 3.3.RedisTemplate</span><br><span class="line"></span><br><span class="line">在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</span><br><span class="line"></span><br><span class="line">下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</span><br><span class="line"></span><br><span class="line">### 3.3.1.导入Demo工程</span><br><span class="line"></span><br><span class="line">首先，我们引入课前资料提供的Demo工程：</span><br><span class="line"></span><br><span class="line">![image-20230504212722302](https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212722302.png)</span><br><span class="line"></span><br><span class="line">### 3.3.2.引入依赖</span><br><span class="line"></span><br><span class="line">在项目的pom文件中引入依赖：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-配置Redis地址"><a href="#3-3-3-配置Redis地址" class="headerlink" title="3.3.3.配置Redis地址"></a>3.3.3.配置Redis地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">      master: mymaster</span><br><span class="line">      nodes:</span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27001</span></span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27002</span></span><br><span class="line">        - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27003</span></span><br></pre></td></tr></table></figure><h3 id="3-3-4-配置读写分离"><a href="#3-3-4-配置读写分离" class="headerlink" title="3.3.4.配置读写分离"></a>3.3.4.配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul><h1 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4.Redis分片集群"></a>4.Redis分片集群</h1><h2 id="4-1-搭建分片集群"><a href="#4-1-搭建分片集群" class="headerlink" title="4.1.搭建分片集群"></a>4.1.搭建分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212815511.png" alt="image-20230504212815511"></p><p>分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><p>具体搭建流程参考课前资料《Redis集群.md》：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212830354.png" alt="image-20230504212830354"></p><h2 id="4-2-散列插槽"><a href="#4-2-散列插槽" class="headerlink" title="4.2.散列插槽"></a>4.2.散列插槽</h2><h3 id="4-2-1-插槽原理"><a href="#4-2-1-插槽原理" class="headerlink" title="4.2.1.插槽原理"></a>4.2.1.插槽原理</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212846348.png" alt="image-20230504212846348"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212901625.png" alt="image-20230504212901625"></p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p><h3 id="4-2-1-小结"><a href="#4-2-1-小结" class="headerlink" title="4.2.1.小结"></a>4.2.1.小结</h3><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h2 id="4-3-集群伸缩"><a href="#4-3-集群伸缩" class="headerlink" title="4.3.集群伸缩"></a>4.3.集群伸缩</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212920583.png" alt="image-20230504212920583"></p><p>比如，添加节点的命令：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212931650.png" alt="image-20230504212931650"></p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p><ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li></ul><p>这里需要两个新的功能：</p><ul><li>添加一个节点到集群中</li><li>将部分插槽分配到新插槽</li></ul><h3 id="4-3-2-创建新的redis实例"><a href="#4-3-2-创建新的redis实例" class="headerlink" title="4.3.2.创建新的redis实例"></a>4.3.2.创建新的redis实例</h3><p>创建一个文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure><p>拷贝配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure><h3 id="4-3-3-添加新节点到redis"><a href="#4-3-3-添加新节点到redis" class="headerlink" title="4.3.3.添加新节点到redis"></a>4.3.3.添加新节点到redis</h3><p>添加节点的语法如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212948280.png" alt="image-20230504212948280"></p><p>执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node  192.168.150.101:7004 192.168.150.101:7001</span><br></pre></td></tr></table></figure><p>通过命令查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p>如图，7004加入了集群，并且默认是一个master节点：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504212959504.png" alt="image-20230504212959504"></p><p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p><h3 id="4-3-4-转移插槽"><a href="#4-3-4-转移插槽" class="headerlink" title="4.3.4.转移插槽"></a>4.3.4.转移插槽</h3><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213012938.png" alt="image-20230504213012938"></p><p>如上图所示，num的插槽为2765.</p><p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213031504.png" alt="image-20230504213031504"></p><p>具体命令如下：</p><p>建立连接：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213042286.png" alt="image-20230504213042286"></p><p>得到下面的反馈：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213049894.png" alt="image-20230504213049894"></p><p>询问要移动多少个插槽，我们计划是3000个：</p><p>新的问题来了：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213101554.png" alt="image-20230504213101554"></p><p>那个node来接收这些插槽？？</p><p>显然是7004，那么7004节点的id是多少呢？</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213113071.png" alt="image-20230504213113071"></p><p>复制这个id，然后拷贝到刚才的控制台后：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213128934.png" alt="image-20230504213128934"></p><p>这里询问，你的插槽是从哪里移动过来的？</p><ul><li>all：代表全部，也就是三个节点各转移一部分</li><li>具体的id：目标节点的id</li><li>done：没有了</li></ul><p>这里我们要从7001获取，因此填写7001的id：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213139939.png" alt="image-20230504213139939"></p><p>填完后，点击done，这样插槽转移就准备好了：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213148753.png" alt="image-20230504213148753"></p><p>确认要转移吗？输入yes：</p><p>然后，通过命令查看结果：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213201363.png" alt="image-20230504213201363"></p><p>可以看到： </p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213209797.png" alt="image-20230504213209797"></p><p>目的达成。</p><h2 id="4-4-故障转移"><a href="#4-4-故障转移" class="headerlink" title="4.4.故障转移"></a>4.4.故障转移</h2><p>集群初识状态是这样的：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213232919.png" alt="image-20230504213232919"></p><p>其中7001、7002、7003都是master，我们计划让7002宕机。</p><h3 id="4-4-1-自动故障转移"><a href="#4-4-1-自动故障转移" class="headerlink" title="4.4.1.自动故障转移"></a>4.4.1.自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213304834.png" alt="image-20230504213304834"></p><p>3）最后是确定下线，自动提升一个slave为新的master：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213318272.png" alt="image-20230504213318272"></p><p>4）当7002再次启动，就会变为一个slave节点了：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213329170.png" alt="image-20230504213329170"></p><h3 id="4-4-2-手动故障转移"><a href="#4-4-2-手动故障转移" class="headerlink" title="4.4.2.手动故障转移"></a>4.4.2.手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213346005.png" alt="image-20230504213346005"></p><p>这种failover命令可以指定三种模式：</p><ul><li>缺省：默认的流程，如图1~6歩</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul><p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><p>如图：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213411330.png" alt="image-20230504213411330"></p><p>效果：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504213420680.png" alt="image-20230504213420680"></p><h2 id="4-5-RedisTemplate访问分片集群"><a href="#4-5-RedisTemplate访问分片集群" class="headerlink" title="4.5.RedisTemplate访问分片集群"></a>4.5.RedisTemplate访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mapstruct工具</title>
      <link href="/2023/04/19/Mapstruct%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/04/19/Mapstruct%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://mapstruct.org/documentation/stable/reference/html/">官方文档</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTAyMTY2NA==&mid=2247492347&idx=1&sn=d69337c0b0cf4efa70b0d058e43cca38&chksm=c0c3ba74f7b43362993fb365d5fe5574e888874f4ff603a058da7eeb5e58ee99530b1be85535&mpshare=1&scene=23&srcid=0419rMJ8nC3f5B4eAI7MPwTy&sharer_sharetime=1681903945642&sharer_shareid=3409c4ef27266aa7138338f9713dadd3#rd">学习参考</a></p><p>[案例gitee](<a href="https://gitee.com/Yuydot/Springboot-huaxin/tree/master/Springboot-mapstruct">Springboot-mapstruct · YuY&#x2F;Springboot-huaxin - 码云 - 开源中国 (gitee.com)</a>)</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MapStruct是一个Java注释处理器，用于生成类型安全的bean映射类。</p><p>您要做的就是定义一个映射器接口，该接口声明任何必需的映射方法。在编译期间，MapStruct将生成此接口的实现。此实现使用简单的Java方法调用在源对象和目标对象之间进行映射，即没有反射或类似内容。</p><p>与手动编写映射代码相比，MapStruct通过生成繁琐且易于出错的代码来节省时间。遵循配置方法上的约定，MapStruct使用合理的默认值，但在配置或实现特殊行为时不加理会。<br>与动态映射框架相比，MapStruct具有以下优点：</p><ol><li>通过使用普通方法调用（settter&#x2F;getter）而不是反射来快速执行</li><li>编译时类型安全性：只能映射相互映射的对象和属性，不能将order实体意外映射到customer DTO等。</li><li>如果有如下问题，编译时会抛出异常<br>3.1 映射不完整（并非所有目标属性都被映射）<br>3.2 映射不正确（找不到正确的映射方法或类型转换）</li><li>可以通过freemarker定制化开发</li></ol><h3 id="1、maven"><a href="#1、maven" class="headerlink" title="1、maven"></a>1、maven</h3><p>对于基于Maven的项目，将以下内容添加到您的POM文件中以使用MapStruct：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mapStruct依赖 高性能对象映射--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapstruct核心--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapstruct编译--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Lombok依赖：（版本最好在1.16.16以上，否则会出现问题）通常是和lombok一起使用<br>的</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lombok dependencies should not end up on classpath --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于lombok和mapstruct的版本兼容问题多说几句，maven插件要使用3.6.0版本以上、lombok使用1.16.16版本以上，另外编译的lombok mapstruct的插件不要忘了加上。否则会出现下面的错误：No property named “aaa” exists in source parameter(s). Did you mean “null”?</p><p>这种异常就是lombok编译异常导致缺少get setter方法造成的。还有就是缺少构造函数也会抛异常。</p></blockquote><h3 id="2、普通转换"><a href="#2、普通转换" class="headerlink" title="2、普通转换"></a>2、普通转换</h3><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> GenderEnum gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GenderEnum.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">GenderEnum</span> &#123;</span><br><span class="line">    Male(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    Female(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GenderEnum(String code, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentVO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentVO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper(转换工具)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="type">StudentMapper</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;gender.name&quot;, target = &quot;gender&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(source = &quot;birthday&quot;, target = &quot;birthday&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    StudentVO <span class="title function_">student2StudentVO</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类是开发过程少不了的，就算是用工具生成肯定也是要有的，需要手写的部分就是这个Mapper的接口，编译完成后会自动生成相应的实现类</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419205228810.png" alt="image-20230419205228810"></p><p>然后就可以直接用mapper进行实体的转换了</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .age(<span class="number">6</span>)</span><br><span class="line">            .gender(GenderEnum.Male)</span><br><span class="line">            .height(<span class="number">121.1</span>)</span><br><span class="line">            .birthday(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">            .build();</span><br><span class="line">    System.out.println(student);</span><br><span class="line">    <span class="comment">//这行代码便是实际要用的代码</span></span><br><span class="line">    <span class="type">StudentVO</span> <span class="variable">studentVO</span> <span class="operator">=</span> StudentMapper.INSTANCE.student2StudentVO(student);</span><br><span class="line">    System.out.println(studentVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419205402771.png" alt="image-20230419205402771"></p><p>mapper可以进行字段映射，改变字段类型，指定格式化的方式，包括一些日期的默认处理。</p><p>可以手动指定格式化的方法：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419205612209.png" alt="image-20230419205612209"></p><p>上面只是最简单的实体映射处理，下面介绍一些高级用法</p><h3 id="3、List转换"><a href="#3、List转换" class="headerlink" title="3、List转换"></a>3、List转换</h3><p>属性映射基于上面的mapping配置</p><p><code> List&lt;StudentVO&gt; students2StudentVOs(List&lt;Student&gt; studentList);</code> </p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()</span><br><span class="line">                .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">                .age(<span class="number">6</span>)</span><br><span class="line">                .gender(GenderEnum.Male)</span><br><span class="line">                .height(<span class="number">121.1</span>)</span><br><span class="line">                .birthday(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> Student.builder()</span><br><span class="line">                .name(<span class="string">&quot;小芳&quot;</span>)</span><br><span class="line">                .age(<span class="number">12</span>)</span><br><span class="line">                .gender(GenderEnum.Female)</span><br><span class="line">                .height(<span class="number">131.1</span>)</span><br><span class="line">                .birthday(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .build();</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(student);</span><br><span class="line">        list.add(student2);</span><br><span class="line">        List&lt;StudentVO&gt; result = StudentMapper.INSTANCE.students2StudentVOs(list);</span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419210138052.png" alt="image-20230419210138052"></p><h3 id="4、多对象转换到一个对象"><a href="#4、多对象转换到一个对象" class="headerlink" title="4、多对象转换到一个对象"></a>4、多对象转换到一个对象</h3><p>新增  Course.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sortNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentVO2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentVO2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    <span class="keyword">private</span> String course;  <span class="comment">//新增字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping(source = &quot;student.gender.name&quot;, target = &quot;gender&quot;)</span></span><br><span class="line"><span class="meta">@Mapping(source = &quot;student.birthday&quot;, target = &quot;birthday&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="meta">@Mapping(source = &quot;course.courseName&quot;, target = &quot;course&quot;)</span></span><br><span class="line">StudentVO2 <span class="title function_">studentAndCourse2StudentVO</span><span class="params">(Student student, Course course)</span>;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student</span><br><span class="line">            .builder()</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .age(<span class="number">6</span>)</span><br><span class="line">            .gender(GenderEnum.Male)</span><br><span class="line">            .height(<span class="number">121.1</span>)</span><br><span class="line">            .birthday(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">Course</span> <span class="variable">course</span> <span class="operator">=</span> Course</span><br><span class="line">            .builder()</span><br><span class="line">            .id(<span class="number">1L</span>)</span><br><span class="line">            .courseName(<span class="string">&quot;语文&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">StudentVO2</span> <span class="variable">studentVO</span> <span class="operator">=</span> StudentMapper.INSTANCE.studentAndCourse2StudentVO(student, course);</span><br><span class="line">    System.out.println(studentVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419210947060.png" alt="image-20230419210947060"></p><h3 id="5、默认值"><a href="#5、默认值" class="headerlink" title="5、默认值"></a>5、默认值</h3><p>可以在Mapping映射中给需要的字段设置默认值<code> defaultValue =&quot; &quot;</code></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419211721849.png" alt="image-20230419211721849"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419211821329.png" alt="image-20230419211821329"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419211834952.png" alt="image-20230419211834952"></p><h3 id="6、嵌套映射"><a href="#6、嵌套映射" class="headerlink" title="6、嵌套映射"></a>6、嵌套映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> Child personChild;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDTO</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">private</span> Child child;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mapper</span></span><br><span class="line"><span class="meta">@Mapper(uses =DateFormtUtil.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">PersonMapper</span> <span class="variable">INSTANCT</span> <span class="operator">=</span> Mappers.getMapper(PersonMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;child&quot;, source = &quot;personChild&quot;)</span></span><br><span class="line">    PersonDTO <span class="title function_">conver</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、使用表达式"><a href="#7、使用表达式" class="headerlink" title="7、使用表达式"></a>7、使用表达式</h3><p>目前java是唯一受支持的语言，达式必须以Java表达式的形式给出<br><strong>注意： 这个属性不能与source()、defaultValue()、defaultExpression()、qualifiedBy()、qualifiedByName()或constant()一起使用。</strong></p><p><code> @Mapping(target = &quot;describe&quot;, source = &quot;describe&quot;, defaultValue = &quot;默认值&quot;) @Mapping(target = &quot;createTime&quot;,expression = &quot;java(new java.util.Date())&quot;) PersonDTO conver(Person person);</code></p><p>更多使用姿势 <a href="%5B(148%E6%9D%A1%E6%B6%88%E6%81%AF">参考</a> Mapstruct 使用教程_胡八一 的博客-CSDN博客](<a href="https://blog.csdn.net/qq_44732146/article/details/119968376?ops_request_misc=%7B%22request_id%22:%22168190755016800211550326%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168190755016800211550326&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119968376-null-null.142%5Ev85%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=mapstruct&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_44732146/article/details/119968376?ops_request_misc=%7B%22request%5Fid%22%3A%22168190755016800211550326%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168190755016800211550326&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119968376-null-null.142^v85^koosearch_v1,239^v2^insert_chatgpt&amp;utm_term=mapstruct&amp;spm=1018.2226.3001.4187</a>))</p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mapstruct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ControllerAdvice学习</title>
      <link href="/2023/04/18/ControllerAdvice%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/18/ControllerAdvice%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="ControllerAdvice"></a>ControllerAdvice</h1><p><a href="https://blog.csdn.net/qq_43581790/article/details/123871439?ops_request_misc=&request_id=&biz_id=102&utm_term=controllerAdvice&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123871439.142%5Ev84%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">ControllerAdvice用法</a></p><h2 id="一、全局错误页"><a href="#一、全局错误页" class="headerlink" title="一、全局错误页"></a>一、全局错误页</h2><p>在我们传统的SpringMVC中（基于Tomcat的项目开发中），可以直接通过web.xml配置文件来实现错误页的配置，或者通过1SpringMVC所提供的的配置来实现错误页。但是在Springboot环境下，在通过配置文件去配置就不太合适了。</p><h3 id="1、【浏览器】随意输入一个服务的访问路径（该路径不存在）"><a href="#1、【浏览器】随意输入一个服务的访问路径（该路径不存在）" class="headerlink" title="1、【浏览器】随意输入一个服务的访问路径（该路径不存在）"></a>1、【浏览器】随意输入一个服务的访问路径（该路径不存在）</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230418094112743.png" alt="image-20230418094112743"></p><p>如果说你现在使用的是一个单独的Springboot程序实现了所有的WEB程序开发，以上配置模式还是可以接受的（但是大多数情况下是无法忍受的，一般都是做定制化处理），但是如果要是结合当前流行的前后端设计模式，此时的数据返回类型就不合适了，最佳的做法还是应该返回有Json数据信息。</p><h3 id="2、为了便于程序的管理，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。"><a href="#2、为了便于程序的管理，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。" class="headerlink" title="2、为了便于程序的管理，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。"></a>2、为了便于程序的管理，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/errors/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorPageAction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/error_404&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">errorCode404</span><span class="params">()</span>&#123;   <span class="comment">//错误路径</span></span><br><span class="line">        HttpServletRequest request=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        HttpServletResponse response=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_NOT_FOUND);<span class="comment">//设置响应编码</span></span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//即使是一个错误页也要正常响应</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        map.put(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;无法找到用户访问路径&quot;</span>);<span class="comment">//适当性带点文字描述</span></span><br><span class="line">        map.put(<span class="string">&quot;referer&quot;</span>,request.getHeader(<span class="string">&quot;Referer&quot;</span>));<span class="comment">//获得之前的来源</span></span><br><span class="line">        map.put(<span class="string">&quot;path&quot;</span>,request.getRequestURI());<span class="comment">//获得访问路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、在当前所配置的Action仅仅是错误页的显示，真正想让其生效（替代已经存在的错误页），就需要编写一个配置类。"><a href="#3、在当前所配置的Action仅仅是错误页的显示，真正想让其生效（替代已经存在的错误页），就需要编写一个配置类。" class="headerlink" title="3、在当前所配置的Action仅仅是错误页的显示，真正想让其生效（替代已经存在的错误页），就需要编写一个配置类。"></a>3、在当前所配置的Action仅仅是错误页的显示，真正想让其生效（替代已经存在的错误页），就需要编写一个配置类。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorPageConfig</span> <span class="keyword">implements</span> <span class="title class_">ErrorPageRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> &#123; <span class="comment">//页面注册</span></span><br><span class="line">        ErrorPage errorPage=<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(HttpStatus.NOT_FOUND,<span class="string">&quot;/error/error_404&quot;</span>);<span class="comment">//定义404错误页</span></span><br><span class="line">        registry.addErrorPages(errorPage);<span class="comment">//到此添加错误页成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、【浏览器】启动当前的Springboot程序，随后随意访问一个不存在的路径，观察错误页显示。"><a href="#4、【浏览器】启动当前的Springboot程序，随后随意访问一个不存在的路径，观察错误页显示。" class="headerlink" title="4、【浏览器】启动当前的Springboot程序，随后随意访问一个不存在的路径，观察错误页显示。"></a>4、【浏览器】启动当前的Springboot程序，随后随意访问一个不存在的路径，观察错误页显示。</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230418102446224.png" alt="image-20230418102446224"></p><h3 id="5、除了404的状态码之外，最重要的就是500的错误，首先观察一下默认的500的显示结果。"><a href="#5、除了404的状态码之外，最重要的就是500的错误，首先观察一下默认的500的显示结果。" class="headerlink" title="5、除了404的状态码之外，最重要的就是500的错误，首先观察一下默认的500的显示结果。"></a>5、除了404的状态码之外，最重要的就是500的错误，首先观察一下默认的500的显示结果。</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230418102845282.png" alt="image-20230418102845282"></p><p>这个时候的错误显示并不合理，按照前后端分离设计原则来讲，即便出现了错误，也应该进行Rest数据响应。</p><h3 id="6、同上步骤2，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。"><a href="#6、同上步骤2，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。" class="headerlink" title="6、同上步骤2，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。"></a>6、同上步骤2，创建一个基于Restful风格响应的数据内容，同时基于Action来实现数据响应操作。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/error_500&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">errorCode500</span><span class="params">()</span>&#123;   <span class="comment">//错误路径</span></span><br><span class="line">    HttpServletRequest request=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">    HttpServletResponse response=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line">    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<span class="comment">//设置响应编码</span></span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//即使是一个错误页也要正常响应</span></span><br><span class="line">    map.put(<span class="string">&quot;status&quot;</span>,HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;服务器端程序出错&quot;</span>);<span class="comment">//适当性带点文字描述</span></span><br><span class="line">    map.put(<span class="string">&quot;referer&quot;</span>,request.getHeader(<span class="string">&quot;Referer&quot;</span>));<span class="comment">//获得之前的来源</span></span><br><span class="line">    map.put(<span class="string">&quot;path&quot;</span>,request.getRequestURI());<span class="comment">//获得访问路径</span></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、添加错误页到配置类"><a href="#7、添加错误页到配置类" class="headerlink" title="7、添加错误页到配置类"></a>7、添加错误页到配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorPageConfig</span> <span class="keyword">implements</span> <span class="title class_">ErrorPageRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> &#123; <span class="comment">//页面注册</span></span><br><span class="line">        ErrorPage errorPage404=<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(HttpStatus.NOT_FOUND,<span class="string">&quot;/errors/error_404&quot;</span>);<span class="comment">//定义404错误页</span></span><br><span class="line">        ErrorPage errorPage500=<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(HttpStatus.NOT_FOUND,<span class="string">&quot;/errors/error_500&quot;</span>);<span class="comment">//定义500错误页</span></span><br><span class="line"></span><br><span class="line">        registry.addErrorPages(errorPage404);<span class="comment">//到此添加错误页成功</span></span><br><span class="line">        registry.addErrorPages(errorPage500);<span class="comment">//到此添加错误页成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230418112439169.png" alt="image-20230418112439169"></p><p>此时的错误页是依据返回的HTTP状态码来实现显示处理，只要你有错误页的需要，配置好状态码就可以自动跳转，与单实例唯一的不同是在于此时的代码是基于前后端分离的Rest显示处理的。</p><h2 id="二、全局异常处理器"><a href="#二、全局异常处理器" class="headerlink" title="二、全局异常处理器"></a>二、全局异常处理器</h2><p>在进行程序开发的过程之中，一定要明确，所有的问题除了错误页之外(是根据HTTP状态码的方式来进行匹配的)，另外一种进行错误处理的形式就是全局异常配置。</p><blockquote><p>回顾:在讲解JavaWEB 基础开发的时候曾经讲解过可以直接在项目的 web.xml配置文件里面定义错误页，而这个错误页可以根据HTTP响应状态码（404、500)来进行匹配，或者可以根据异常类型来完成，而在整个的Java里面可以处理的最大异常就是Exception，本次也是基于同样的形式来实现异常操作，只不过实现的是全局异常处理。</p></blockquote><h3 id="1、既然要进行全局异常处理，那么首先需要考虑到的问题就是进行Rest响应处理，主要是符合当前的前后端分离设计的原则。"><a href="#1、既然要进行全局异常处理，那么首先需要考虑到的问题就是进行Rest响应处理，主要是符合当前的前后端分离设计的原则。" class="headerlink" title="1、既然要进行全局异常处理，那么首先需要考虑到的问题就是进行Rest响应处理，主要是符合当前的前后端分离设计的原则。"></a>1、既然要进行全局异常处理，那么首先需要考虑到的问题就是进行Rest响应处理，主要是符合当前的前后端分离设计的原则。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>  <span class="comment">//@ControllerAdvice还有springMVC提供的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果说你现在是包含有一个完整业务需求的项目，可以在此处填写一些自定义的业务异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span><span class="comment">//可以捕获的异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//本次的处理是基于Rest风格完成的</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//保存响应信息</span></span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());<span class="comment">//直接获取异常信息</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<span class="comment">//设置HTTP状态码</span></span><br><span class="line">        map.put(<span class="string">&quot;exception&quot;</span>,e.getClass().getName());<span class="comment">//获取异常类型</span></span><br><span class="line">        HttpServletRequest request=((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        map.put(<span class="string">&quot;path&quot;</span>,request.getRequestURI());<span class="comment">//异常发生的路径</span></span><br><span class="line">        <span class="keyword">return</span> map;<span class="comment">//直接返回对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、创建一个产生异常的Action程序类"><a href="#2、创建一个产生异常的Action程序类" class="headerlink" title="2、创建一个产生异常的Action程序类"></a>2、创建一个产生异常的Action程序类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/create/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateExcepionAction</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;exception&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230418111747622.png" alt="image-20230418111747622"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战2</title>
      <link href="/2023/04/14/Redis%E5%AE%9E%E6%88%982-%E9%BB%91%E9%A9%AC%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/"/>
      <url>/2023/04/14/Redis%E5%AE%9E%E6%88%982-%E9%BB%91%E9%A9%AC%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1、发布探店笔记"><a href="#1、发布探店笔记" class="headerlink" title="1、发布探店笔记"></a>1、发布探店笔记</h2><h3 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h3><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tb_blog`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_blog`  (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `shop_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商户id&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">  `images` <span class="type">varchar</span>(<span class="number">2048</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;探店的照片，最多9张，多张以\&quot;,\&quot;隔开&#x27;</span>,</span><br><span class="line">  `content` <span class="type">varchar</span>(<span class="number">2048</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;探店的文字描述&#x27;</span>,</span><br><span class="line">  `liked` <span class="type">int</span>(<span class="number">8</span>) UNSIGNED <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;点赞数量&#x27;</span>,</span><br><span class="line">  `comments` <span class="type">int</span>(<span class="number">8</span>) UNSIGNED <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论数量&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">23</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230414151340782.png"></p><h3 id="1-2-具体发布流程"><a href="#1-2-具体发布流程" class="headerlink" title="1.2 具体发布流程"></a>1.2 具体发布流程</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428131016509.png" alt="image-20230428131016509"></p><p>上传接口</p><p>为什么单独做一个上传接口？  接口复用，上传文件功能在其他地方也能用，所以不用写在上传文章的接口里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@GetMapping(&quot;/blog/delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">deleteBlogImg</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String filename)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, filename);</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;错误的文件名称&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileUtil.del(file);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">createNewFileName</span><span class="params">(String originalFilename)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> StrUtil.subAfter(originalFilename, <span class="string">&quot;.&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 生成目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> name.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> hash &amp; <span class="number">0xF</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">        <span class="comment">// 判断目录是否存在</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;&quot;</span>, d1, d2));</span><br><span class="line">        <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成文件名</span></span><br><span class="line">        <span class="keyword">return</span> StrUtil.format(<span class="string">&quot;/blogs/&#123;&#125;/&#123;&#125;/&#123;&#125;.&#123;&#125;&quot;</span>, d1, d2, name, suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IMAGE_UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;D:\\lesson\\nginx-1.18.0\\html\\hmdp\\imgs\\&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_NICK_NAME_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;user_&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、查看探店笔记"><a href="#2、查看探店笔记" class="headerlink" title="2、查看探店笔记"></a>2、查看探店笔记</h2><h3 id="2-1-实现查看发布探店笔记的接口"><a href="#2-1-实现查看发布探店笔记的接口" class="headerlink" title="2.1 实现查看发布探店笔记的接口"></a>2.1 实现查看发布探店笔记的接口</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428132945771.png" alt="image-20230428132945771"></p><p>实现代码：</p><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    <span class="comment">//为什么要这样操作？因为在blog在数据中没有NickName和Icon字段，所以要手动添加</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queryBlogUser</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">    blog.setName(user.getNickName());</span><br><span class="line">    blog.setIcon(user.getIcon());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、点赞功能"><a href="#3、点赞功能" class="headerlink" title="3、点赞功能"></a>3、点赞功能</h2><h3 id="3-1-实现查看点赞功能的接口"><a href="#3-1-实现查看点赞功能的接口" class="headerlink" title="3.1 实现查看点赞功能的接口"></a>3.1 实现查看点赞功能的接口</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/761d5b05a2297825ea4034568add4d3a.png" alt="image-20221120085007488"></p><p>初始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-问题分析"><a href="#3-2-问题分析" class="headerlink" title="3.2 问题分析"></a>3.2 问题分析</h3><p>这种方式会导致一个用户无限点赞，明显是不合理的。</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p><h3 id="3-3-完善点赞功能"><a href="#3-3-完善点赞功能" class="headerlink" title="3.3 完善点赞功能"></a>3.3 完善点赞功能</h3><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是唯一</p><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><p>(1) 在Blog 添加一个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure><p>(2) 修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞  BLOG_LIKED_KEY=&quot;blog:liked:&quot;</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>(3) 当我们点开一篇blog的时候就需要被看到是否点赞过，这就要求我们改一下queryBlogById(id)咯，当然isLikeBlog(blog)也是需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span>(blog==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.查询blog相关用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">    <span class="comment">//3.查询用户是否点过赞,其实就是给blog的isLike添加值</span></span><br><span class="line">    isLikeBlog(blog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isLikeBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">    blog.setIsLike(BooleanUtil.isTrue(isMember));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        records.forEach(blog-&gt;&#123;</span><br><span class="line">            <span class="built_in">this</span>.queryBlogUser(blog);</span><br><span class="line">            <span class="built_in">this</span>.isLikeBlog(blog);</span><br><span class="line">        &#125;);<span class="comment">//就是用blog遍历的</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、点赞排行榜"><a href="#4、点赞排行榜" class="headerlink" title="4、点赞排行榜"></a>4、点赞排行榜</h2><h3 id="4-1、分析："><a href="#4-1、分析：" class="headerlink" title="4.1、分析："></a>4.1、分析：</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/31c8bee2eae1effd0a1c47ce2200d4fa.png" alt="image-20221120110940588"></p><p>Redis的set存储的like无序，所以需要用到sortedset</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/86dbee0f5200a2315453f87ab21f6c0c.png" alt="image-20221120111044374"></p><h3 id="4-2、修改BlogServiceImpl"><a href="#4-2、修改BlogServiceImpl" class="headerlink" title="4.2、修改BlogServiceImpl"></a>4.2、修改BlogServiceImpl</h3><p>BlogServiceImpl：点赞逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score(时间戳)</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">            <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、点赞列表查询列表"><a href="#4-3、点赞列表查询列表" class="headerlink" title="4.3、点赞列表查询列表"></a>4.3、点赞列表查询列表</h3><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id,然后根据UserId查询到user,再转化为UserDto</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//看不懂这样写</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS  =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,userDTO);</span><br><span class="line">        userDTOS.add(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、关注和取关"><a href="#5、关注和取关" class="headerlink" title="5、关注和取关"></a>5、关注和取关</h2><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428141217902.png" alt="image-20230428141217902"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428141335759.png" alt="image-20230428141335759"></p><p>注意: 这里需要把主键修改为自增长，简化开发。</p><h3 id="5-1-关注"><a href="#5-1-关注" class="headerlink" title="5.1 关注"></a>5.1 关注</h3><p>FollowController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注(其实是判断当前用户有没有关注)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FollowService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消关注service(判断当前用户有没有关注)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关注servic  isFollow==true 取消关注 &amp;&amp; isFollow==false 关注</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">               .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-共同关注"><a href="#5-2-共同关注" class="headerlink" title="5.2 共同关注"></a>5.2 共同关注</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428142753350.png" alt="image-20230428142753350">想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line"><span class="comment">// 查询详情</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"><span class="comment">// 根据用户查询</span></span><br><span class="line">Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line"><span class="comment">// 获取当前页数据</span></span><br><span class="line">List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line"><span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看共同关注如何实现：</p><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用set集合，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428143205898.png" alt="image-20230428143205898"></p><p>先改造当前的关注列表</p><p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的关注代码：</strong></p><p>FollowServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> followService.followCommons(followUserId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-Feed流实现方案"><a href="#5-3-Feed流实现方案" class="headerlink" title="5.3 Feed流实现方案"></a>5.3 Feed流实现方案</h3><h4 id="5-3-1-什么是Feed流"><a href="#5-3-1-什么是Feed流" class="headerlink" title="5.3.1  什么是Feed流"></a>5.3.1  什么是Feed流</h4><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428145732900.png" alt="image-20230428145732900"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428145748376.png" alt="image-20230428145748376"></p><h4 id="5-3-2-Feed流实现模式"><a href="#5-3-2-Feed流实现模式" class="headerlink" title="5.3.2 Feed流实现模式"></a>5.3.2 Feed流实现模式</h4><p>Feed流产品有两种常见模式：<br><strong>Timeline：</strong>不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p><strong>智能排序：</strong>利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</p></li><li><p>缺点：如果算法不精准，可能起到反作用</p><p>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</p></li></ul><h4 id="5-3-3-Feed流的Timeline模式"><a href="#5-3-3-Feed流的Timeline模式" class="headerlink" title="5.3.3 Feed流的Timeline模式"></a>5.3.3 Feed流的Timeline模式</h4><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428150145049.png" alt="image-20230428150145049"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428150221619.png" alt="image-20230428150221619"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428150236928.png" alt="image-20230428150236928"></p><p>对比</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/07608789a608d54e99c44655868d3ad4.png" alt="image-20221120204125760"></p><p>用户不多，所以选择推模式即可</p><h3 id="5-4-推送到粉丝收件箱"><a href="#5-4-推送到粉丝收件箱" class="headerlink" title="5.4 推送到粉丝收件箱"></a>5.4 推送到粉丝收件箱</h3><h4 id="5-4-1-需求"><a href="#5-4-1-需求" class="headerlink" title="5.4.1 需求"></a>5.4.1 需求</h4><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><h4 id="5-4-2-Feed流使用传统分页弊端"><a href="#5-4-2-Feed流使用传统分页弊端" class="headerlink" title="5.4.2 Feed流使用传统分页弊端"></a>5.4.2 Feed流使用传统分页弊端</h4><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428152648180.png" alt="image-20230428152648180"></p><h4 id="5-4-3-Feed流的滚动分页"><a href="#5-4-3-Feed流的滚动分页" class="headerlink" title="5.4.3 Feed流的滚动分页"></a>5.4.3 Feed流的滚动分页</h4><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据<strong>时间戳</strong>最小值，就可以实现滚动分页了。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428152945866.png" alt="image-20230428152945866"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/fb3eb3da4a741a93ba0b518ab89be6dd.png" alt="image-20221120211239118"></p><p><strong>发布后：</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/a0f1ea19761a64397b012e9f8a0d5b4b.png" alt="image-20221120211755038"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/0360bdea95bac17dde8bd41953601168.png" alt="image-20221120212006847"></p><p><strong>查看1,1010用户的收件箱：</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/afd423c5c3bc61e5bd32437af844511b.png" alt="image-20221120212248681"></p><h4 id="5-4-4-滚动分页查询收件箱"><a href="#5-4-4-滚动分页查询收件箱" class="headerlink" title="5.4.4 滚动分页查询收件箱"></a>5.4.4 滚动分页查询收件箱</h4><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/eb32ef4ef82a6ca9366d402702b88f2a.png" alt="image-20221121095730373"></p><p>所以不能用角标 只能用score</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/ebd14154925f7e5e934b3597754eace5.png" alt="image-20221121100608075"></p><p>limit后面的数据就是偏移量，决定取不取得到端点，第一次就要给0，之后的都要给1 (但是不行)</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/42ac032611a15167493213163a9f80eb.png" alt="image-20221121100914781"></p><p>有相同值的话，用score的话会重复查</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/c9b2a69baa20d7aecd67bd393edf936e.png" alt="image-20221121101116497"></p><p>把limit后面的数字改为 <strong>上一次查询的最小值的重复数字的个数</strong></p><h3 id="5-5-实现滚动分页查询"><a href="#5-5-实现滚动分页查询" class="headerlink" title="5.5 实现滚动分页查询"></a>5.5 实现滚动分页查询</h3><h4 id="5-5-1-需求"><a href="#5-5-1-需求" class="headerlink" title="5.5.1 需求"></a>5.5.1 需求</h4><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428153721379.png" alt="image-20230428153721379"></p><h4 id="5-5-2-定义出来具体的返回值实体类"><a href="#5-5-2-定义出来具体的返回值实体类" class="headerlink" title="5.5.2 定义出来具体的返回值实体类"></a>5.5.2 定义出来具体的返回值实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogController</p><blockquote><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、附近商户"><a href="#6、附近商户" class="headerlink" title="6、附近商户"></a>6、附近商户</h2><h3 id="6-1-GEO数据结构的基本用法"><a href="#6-1-GEO数据结构的基本用法" class="headerlink" title="6.1 GEO数据结构的基本用法"></a>6.1 GEO数据结构的基本用法</h3><p>附近商铺一般Es使用，这里的话还是用Redis</p><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/13a3ce0054df7a372635f44d333b37ce.png" alt="image-20221121150140938"></p><p><strong>添加数据</strong></p><p><code>geoadd g1 116.37 39.86 bjn 116.42 39.90 bj 116.32 39.89 bjx</code></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/f3a110e8cc1a77cd4cdcbd707a2a7a74.png" alt="image-20221121151033461"></p><p><strong>计算两站距离</strong></p><p><code>geodist g1 bjx bj km(默认m)</code></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/a69424302789f3df16d2293f56e7a8c9.png" alt="image-20221121151229007"></p><p><strong>以某地为圆心搜索某范围的所有火车站</strong></p><p><code>geosearch g1  fromlonlat 116.39 39.90 byradius 10 km (asc|desc) (withdist)</code></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/418ed1e449e55074a93c1e43983fb9df.png" alt="image-20221121151854471"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/84213024bfcd37baa9e2733da24893c0.png" alt="image-20221121151940620"></p><p>可以看出默认是距离升序</p><h3 id="6-2-导入店铺数据到GEO"><a href="#6-2-导入店铺数据到GEO" class="headerlink" title="6.2 导入店铺数据到GEO"></a>6.2 导入店铺数据到GEO</h3><p>具体场景说明：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428165207770.png" alt="image-20230428165207770"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428165253142.png" alt="image-20230428165253142"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码：</p><p>HmDianPingApplicationTests</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-实现附近商户功能"><a href="#6-3-实现附近商户功能" class="headerlink" title="6.3 实现附近商户功能"></a>6.3 实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：</p><p>ShopController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShopServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7、用户签到"><a href="#7、用户签到" class="headerlink" title="7、用户签到"></a>7、用户签到</h2><h3 id="7-1-BitMap功能演示"><a href="#7-1-BitMap功能演示" class="headerlink" title="7.1  BitMap功能演示"></a>7.1  BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428165646986.png" alt="image-20230428165646986"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428165806923.png" alt="image-20230428165806923"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h3 id="7-2-实现签到功能"><a href="#7-2-实现签到功能" class="headerlink" title="7.2 实现签到功能"></a>7.2 实现签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230428165955252.png" alt="image-20230428165955252"></p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/20478a52c4ee44e233aaec10ca672921.png" alt="image-20221121222942830"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/dd132bf6cc502953718edc970df1d9d3.png" alt="image-20221121223022948"></p><h3 id="7-3-签到统计"><a href="#7-3-签到统计" class="headerlink" title="7.3 签到统计"></a>7.3 签到统计</h3><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504155013983.png" alt="image-20230504155013983"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504155227406.png" alt="image-20230504155227406"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/b027b277936ae3fee7671be565db48cb.png" alt="image-20221122104746525"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/9c5629b88022228a85976b56c1e130ab.png" alt="image-20221122104723252"></p><h3 id="7-4-关于使用bitmap来解决缓存穿透的方案"><a href="#7-4-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="7.4 关于使用bitmap来解决缓存穿透的方案"></a>7.4 关于使用bitmap来解决缓存穿透的方案</h3><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504155753110.png" alt="image-20230504155753110"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504155804723.png" alt="image-20230504155804723"></p><h2 id="8、UV统计"><a href="#8、UV统计" class="headerlink" title="8、UV统计"></a>8、UV统计</h2><h3 id="8-1-HyperLogLog"><a href="#8-1-HyperLogLog" class="headerlink" title="8.1 HyperLogLog"></a>8.1 HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230504161612994.png" alt="image-20230504161612994"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/fe229be298dde84c73562d3fc35d1103.png" alt="image-20221122110053643"></p><h3 id="8-2-测试百万数据的统计"><a href="#8-2-测试百万数据的统计" class="headerlink" title="8.2 测试百万数据的统计"></a>8.2 测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] values = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">        j=i%<span class="number">1000</span>;</span><br><span class="line">        values[j]=<span class="string">&quot;user_&quot;</span>+i;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">999</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;hl2&quot;</span>,values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计数量</span></span><br><span class="line">    System.out.println(stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;hl2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试一百万个数据，最后存入997593个数据，内存一开始是1679336，现在变成1693720，相差14384，也就是14.046875kb,没超过16kb。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/b4263f5eafa3709676a57e7f55220d17.png" alt="image-20221122111243033"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p><p><a href="https://blog.csdn.net/weixin_51515308/article/details/128010464?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168265841116800180697885%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168265841116800180697885&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128010464-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%BB%91%E9%A9%ACredis%E5%AE%9E%E6%88%98%E7%AF%87&spm=1018.2226.3001.4187">参考笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战1</title>
      <link href="/2023/04/11/Redis%E5%AE%9E%E6%88%981-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/04/11/Redis%E5%AE%9E%E6%88%981-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis实战1"><a href="#Redis实战1" class="headerlink" title="Redis实战1"></a>Redis实战1</h1><h2 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h2><h3 id="1-1、什么是缓存"><a href="#1-1、什么是缓存" class="headerlink" title="1.1、什么是缓存?"></a>1.1、什么是缓存?</h3><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码。</p><h3 id="1-2、为什么要使用缓存"><a href="#1-2、为什么要使用缓存" class="headerlink" title="1.2、为什么要使用缓存"></a>1.2、为什么要使用缓存</h3><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411134252670.png" alt="image-20230411134252670"></p><h3 id="1-3、如何使用缓存"><a href="#1-3、如何使用缓存" class="headerlink" title="1.3、如何使用缓存"></a>1.3、如何使用缓存</h3><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411134353556.png" alt="image-20230411134353556"></p><h3 id="1-4、缓存更新策略"><a href="#1-4、缓存更新策略" class="headerlink" title="1.4、缓存更新策略"></a>1.4、缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)。</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存。</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411134514644.png" alt="image-20230411134514644"></p><h3 id="1-5、数据库缓存不一致解决方案："><a href="#1-5、数据库缓存不一致解决方案：" class="headerlink" title="1.5、数据库缓存不一致解决方案："></a>1.5、数据库缓存不一致解决方案：</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案：</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411134645948.png" alt="image-20230411134645948"></p><h3 id="1-6、数据库和缓存不一致采用什么方案"><a href="#1-6、数据库和缓存不一致采用什么方案" class="headerlink" title="1.6、数据库和缓存不一致采用什么方案"></a>1.6、数据库和缓存不一致采用什么方案</h3><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411134824863.png"></p><h3 id="1-7、实现商铺和缓存与数据库双写一致"><a href="#1-7、实现商铺和缓存与数据库双写一致" class="headerlink" title="1.7、实现商铺和缓存与数据库双写一致"></a>1.7、实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411135121152.png" alt="image-20230411135121152"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411135238783.png" alt="image-20230411135238783"></p><h2 id="2、缓存查询"><a href="#2、缓存查询" class="headerlink" title="2、缓存查询"></a>2、缓存查询</h2><blockquote><p>模拟购物平台进行商品查询</p></blockquote><h3 id="2-1、数据库准备"><a href="#2-1、数据库准备" class="headerlink" title="2.1、数据库准备"></a>2.1、数据库准备</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411131724917.png" alt="image-20230411131724917"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411131757291.png" alt="image-20230411131757291"></p><h3 id="2-2、新建项目-导入依赖"><a href="#2-2、新建项目-导入依赖" class="headerlink" title="2.2、新建项目-导入依赖"></a>2.2、新建项目-导入依赖</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411131857601.png" alt="image-20230411131857601"></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Springboot-Redis01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--    排除一下依赖        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    redisson依赖    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- fastjson2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、添加商品缓存"><a href="#2-3、添加商品缓存" class="headerlink" title="2.3、添加商品缓存"></a>2.3、添加商品缓存</h3><blockquote><p>需求：在查询商品时先从缓存中查，查到则直接拿出来用；查不到就查数据库，然后将查到的数据写入缓存。注意：为了避免缓存的内容过大，我们需要设置一个过期时间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getAllGoods</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//先查缓存中是否有</span></span><br><span class="line">    log.info(<span class="string">&quot;查缓存&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">goods</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_GOODS_KEY);</span><br><span class="line">    System.out.println(<span class="string">&quot;Cache-goods&quot;</span>+goods);</span><br><span class="line">    ObjectMapper objectMapper=<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="comment">//缓存中有就返回</span></span><br><span class="line">    <span class="keyword">if</span>(goods!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">CollectionType</span> <span class="variable">collectionType</span> <span class="operator">=</span> objectMapper.getTypeFactory().constructCollectionType(ArrayList.class, Goods.class);</span><br><span class="line">        List&lt;Goods&gt; goods1 = objectMapper.readValue(goods, collectionType);</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,goods1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中没有就查数据库</span></span><br><span class="line">    log.info(<span class="string">&quot;查数据库&quot;</span>);</span><br><span class="line">    List&lt;Goods&gt; allGoods = goodsMapper.getAllGoods();</span><br><span class="line">    System.out.println(<span class="string">&quot;DataBase-allGoods&quot;</span>+allGoods);</span><br><span class="line">    <span class="keyword">if</span>(allGoods.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,<span class="string">&quot;商品数据为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数据写入缓存</span></span><br><span class="line"></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_GOODS_KEY,objectMapper.writeValueAsString(allGoods),CACHE_GOODS_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.buildResult(Result.Status.OK,allGoods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132224375.png" alt="image-20230411132224375"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132332355.png" alt="image-20230411132332355"></p><p><strong>再次查询</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411133134008.png" alt="image-20230411133134008"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132447107.png" alt="image-20230411132447107"></p><p>可以看出，第二次查询速度快了很多。</p><h3 id="2-4、根据商品id查商品"><a href="#2-4、根据商品id查商品" class="headerlink" title="2.4、根据商品id查商品"></a>2.4、根据商品id查商品</h3><blockquote><p>需求：同样先从缓存中查，查到则返回数据；反之，查数据库，将查回数据写入缓存。</p></blockquote><p>参考黑马实战项目</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411133636441.png" alt="image-20230411133636441"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getGoodsById</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//先查缓存</span></span><br><span class="line">    log.info(<span class="string">&quot;查缓存&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">goodsString</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_GOODS_KEY+id);</span><br><span class="line">    System.out.println(<span class="string">&quot;Cache-goodsString&quot;</span>+goodsString);</span><br><span class="line">    ObjectMapper objectMapper=<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="comment">//缓存中存在就返回</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(goodsString))&#123;</span><br><span class="line">        Goods goods=objectMapper.readValue(goodsString,Goods.class);</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,goods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中不存在就查数据库</span></span><br><span class="line">    log.info(<span class="string">&quot;查数据库&quot;</span>);</span><br><span class="line">    <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodsMapper.getGoodById(id);</span><br><span class="line">    System.out.println(<span class="string">&quot;DataBase-goods&quot;</span>+goods);</span><br><span class="line">    <span class="comment">//数据库中不存在，返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(goods==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据库中存在，将查到的数据写入redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">good</span> <span class="operator">=</span> objectMapper.writeValueAsString(goods);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_GOODS_KEY+id,good,CACHE_GOODS_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.buildResult(Result.Status.OK,goods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132813910.png" alt="image-20230411132813910"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132846243.png" alt="image-20230411132846243"></p><p><strong>再次查询</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411132953159.png" alt="image-20230411132953159"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411133053879.png" alt="image-20230411133053879"></p><h3 id="2-5、更新商品"><a href="#2-5、更新商品" class="headerlink" title="2.5、更新商品"></a>2.5、更新商品</h3><blockquote><p>需求：通过客户端传回的数据更新数据库，删除缓存，保证数据库和缓存数据高度一致性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">UpdateGoods</span><span class="params">(Goods goods)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">gid</span> <span class="operator">=</span> goods.getGid();</span><br><span class="line">    <span class="keyword">if</span>(gid==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.NOT_FOUND,<span class="string">&quot;商品id不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新数据库</span></span><br><span class="line">    goodsMapper.updateById(goods);</span><br><span class="line">    <span class="comment">//删缓存</span></span><br><span class="line">    stringRedisTemplate.delete(CACHE_GOODS_KEY+gid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、缓存穿透"><a href="#3、缓存穿透" class="headerlink" title="3、缓存穿透"></a>3、缓存穿透</h2><h3 id="3-1、缓存穿透问题的解决思路"><a href="#3-1、缓存穿透问题的解决思路" class="headerlink" title="3.1、缓存穿透问题的解决思路"></a>3.1、缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在<strong>缓存</strong>中和<strong>数据库</strong>中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，假设布隆过滤器判断这个数据不存在，则直接返回。        这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411135850960.png" alt="image-20230411135850960"></p><h3 id="3-2、编码解决商品查询的缓存穿透问题："><a href="#3-2、编码解决商品查询的缓存穿透问题：" class="headerlink" title="3.2、编码解决商品查询的缓存穿透问题："></a>3.2、编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411140113102.png" alt="image-20230411140113102"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h2 id="4、缓存雪崩"><a href="#4、缓存雪崩" class="headerlink" title="4、缓存雪崩"></a>4、缓存雪崩</h2><h3 id="4-1、缓存雪崩问题及解决思路"><a href="#4-1、缓存雪崩问题及解决思路" class="headerlink" title="4.1、缓存雪崩问题及解决思路"></a>4.1、缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411140548584.png" alt="image-20230411140548584"></p><h2 id="5、缓存击穿"><a href="#5、缓存击穿" class="headerlink" title="5、缓存击穿"></a>5、缓存击穿</h2><h3 id="5-1、缓存击穿问题的解决思路"><a href="#5-1、缓存击穿问题的解决思路" class="headerlink" title="5.1、缓存击穿问题的解决思路"></a>5.1、缓存击穿问题的解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411140856349.png" alt="image-20230411140856349"></p><h3 id="解决方案一、使用锁来解决："><a href="#解决方案一、使用锁来解决：" class="headerlink" title="解决方案一、使用锁来解决："></a>解决方案一、使用锁来解决：</h3><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411140920102.png" alt="image-20230411140920102"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411140938167.png" alt="image-20230411140938167"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411141005321.png" alt="image-20230411141005321"></p><h3 id="5-2、利用互斥锁解决缓存击穿问题"><a href="#5-2、利用互斥锁解决缓存击穿问题" class="headerlink" title="5.2、利用互斥锁解决缓存击穿问题"></a>5.2、利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411141148686.png" alt="image-20230411141148686"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、利用逻辑过期解决缓存击穿问题"><a href="#5-3、利用逻辑过期解决缓存击穿问题" class="headerlink" title="5.3、利用逻辑过期解决缓存击穿问题"></a>5.3、利用逻辑过期解决缓存击穿问题</h3><p>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411141345663.png" alt="image-20230411141345663"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411141446633.png" alt="image-20230411141446633"></p><p>在测试类中</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230411141501881.png" alt="image-20230411141501881"></p><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1、封装Redis工具类"><a href="#5-1、封装Redis工具类" class="headerlink" title="5.1、封装Redis工具类"></a>5.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT单点登录实例</title>
      <link href="/2023/04/10/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E4%BE%8B/"/>
      <url>/2023/04/10/JWT%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT单点登录实例"><a href="#JWT单点登录实例" class="headerlink" title="JWT单点登录实例"></a>JWT单点登录实例</h1><h2 id="1、什么是JWT"><a href="#1、什么是JWT" class="headerlink" title="1、什么是JWT"></a>1、什么是JWT</h2><p>参考<a href="%5Bhttps://yuydot.gitee.io/2023/03/31/JWT%E8%AF%A6%E8%A7%A3/%5D(https://yuydot.gitee.io/2023/03/31/JWT%E8%AF%A6%E8%A7%A3/)">JWT详解</a></p><h2 id="2、实例演示"><a href="#2、实例演示" class="headerlink" title="2、实例演示"></a>2、实例演示</h2><h3 id="2-1、参考图"><a href="#2-1、参考图" class="headerlink" title="2.1、参考图"></a>2.1、参考图</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6b3661a0b8604bd784e4e8343e720a94.png" alt="6b3661a0b8604bd784e4e8343e720a94"></p><h3 id="2-2、依赖导入"><a href="#2-2、依赖导入" class="headerlink" title="2.2、依赖导入"></a>2.2、依赖导入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT相关 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、JWT工具类"><a href="#2-3、JWT工具类" class="headerlink" title="2.3、JWT工具类"></a>2.3、JWT工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/3/22 10:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token过期时间，设置30min</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token字符串的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名,5min后过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName 用户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 用户邮箱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJwtToken</span><span class="params">(<span class="type">int</span> userId,String userName, String email)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+EXPIRE_TIME);</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(email);<span class="comment">//将邮箱作为秘钥（盐值）</span></span><br><span class="line">        <span class="comment">// 附带username信息</span></span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .withClaim(<span class="string">&quot;userName&quot;</span>, userName)</span><br><span class="line">                .withClaim(<span class="string">&quot;email&quot;</span>, email)</span><br><span class="line">                .withExpiresAt(date)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email 用户邮箱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String token, String email)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(email);</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(algorithm)</span><br><span class="line">                    .build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;验证token失败 &#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得token中的信息无需password解密也能获得</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token中包含的用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserId</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">            Collection&lt;Claim&gt; values = jwt.getClaims().values();<span class="comment">//或得token里的用户信息</span></span><br><span class="line">            <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获得token中用户id失败 &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得token中的信息无需password解密也能获得</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token中包含的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">            Collection&lt;Claim&gt; values = jwt.getClaims().values();<span class="comment">//或得token里的用户信息</span></span><br><span class="line">             Integer userId=Integer.parseInt(jwt.getClaim(<span class="string">&quot;userId&quot;</span>).toString());</span><br><span class="line">            <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> jwt.getClaim(<span class="string">&quot;userName&quot;</span>).toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> jwt.getClaim(<span class="string">&quot;email&quot;</span>).toString();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>(userId,userName,email);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获得token中用户失败 &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、拦截器"><a href="#2-4、拦截器" class="headerlink" title="2.4、拦截器"></a>2.4、拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/3/22 9:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private UsersMapper usersMapper;  //这里好像不能使用注解引入userMapper,因为这个拦截器是我们手动写的，不是springboot提供的,所以使用构造器引入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> UsersMapper usersMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate redisTemplate,UsersMapper usersMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate=redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.usersMapper=usersMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(accessToken);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(LOGIN_TOKEN_KEY);</span><br><span class="line">        <span class="keyword">if</span>(accessToken==<span class="literal">null</span>||!accessToken.equals(s))&#123;</span><br><span class="line">            <span class="comment">//判断用户是否存在</span></span><br><span class="line">            <span class="comment">// 不存在就拦截</span></span><br><span class="line">            log.info(<span class="string">&quot;请先登录！&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> JWTUtils.getUser(accessToken);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存在就保存到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(user);<span class="comment">//为什么存dto不存user，因为user类包含很多敏感信息（密码啥的）</span></span><br><span class="line">        <span class="comment">//刷新token的有效期：为什么要刷新？为什么使用session时没有这个问题？</span></span><br><span class="line">        <span class="comment">//假如我们为session设置了30分钟有效期，但只要我们一直访问，那session的有效期就一直是30分钟，</span></span><br><span class="line">        <span class="comment">// 而在redis中则不同，无论你访不访问，过了三十分钟，token就会失效，这时用户就需要重新登录，影响用户体验，所以需要刷新有效期</span></span><br><span class="line">        redisTemplate.opsForValue().set(LOGIN_TOKEN_KEY,accessToken,LOGIN_TOKEN_TTL, TimeUnit.MINUTES);</span><br><span class="line">        log.info(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5、注册拦截器"><a href="#2-5、注册拦截器" class="headerlink" title="2.5、注册拦截器"></a>2.5、注册拦截器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    /*  </span><br><span class="line">      * @Desc 设置静态资源映射</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private FileUtils fileUtils;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UsersMapper mapper;</span><br><span class="line"></span><br><span class="line">    //资源过滤</span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        //资源处理器,映射位置</span><br><span class="line">        log.info(&quot;开始进行静态资源映射...&quot;);</span><br><span class="line">        registry.addResourceHandler(&quot;/backend/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/backend/&quot;);</span><br><span class="line">        registry.addResourceHandler(&quot;/front/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/front/&quot;);</span><br><span class="line">        // 加入头像文件夹映射 可通过 localhost:7188/headimage/....   访问到指定位置的图片</span><br><span class="line">        registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:/backend/&quot;); // 默认头像</span><br><span class="line">        registry.addResourceHandler(&quot;/avatars/**&quot;).addResourceLocations(&quot;file:&quot;+FileUtils.UPLOAD_DIR+ File.separator);</span><br><span class="line">        log.info(&quot;头像存放地址： &quot;+FileUtils.UPLOAD_DIR);</span><br><span class="line">    &#125;</span><br><span class="line">    //添加拦截器</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry)&#123;</span><br><span class="line">        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate,mapper))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        &quot;/*&quot;</span><br><span class="line">//                        &quot;/sendEmail&quot;,</span><br><span class="line">//                        &quot;/login&quot;,</span><br><span class="line">//                        &quot;/backend/**&quot;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、UserHoder工具类-将用户信息保存到线程中"><a href="#2-6、UserHoder工具类-将用户信息保存到线程中" class="headerlink" title="2.6、UserHoder工具类(将用户信息保存到线程中)"></a>2.6、UserHoder工具类(将用户信息保存到线程中)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-登录使用JWT"><a href="#2-7-登录使用JWT" class="headerlink" title="2.7 登录使用JWT"></a>2.7 登录使用JWT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">loginIn</span><span class="params">(LoginVO loginVO)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginEmail</span> <span class="operator">=</span> loginVO.getEmail();</span><br><span class="line">        <span class="keyword">if</span> (!RegexUtils.isEmailInvalid(loginEmail)) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;输入的邮箱格式不对&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;输入的邮箱格式不对&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;Users&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> usersMapper.selectOne(queryWrapper.eq(Users::getUserEmail, loginVO.getEmail()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">Pwd</span> <span class="operator">=</span> CommonUtils.MD5(loginVO.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!user.getUserPassword().equals(Pwd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;密码不正确&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWTUtils.getJwtToken(user.getUserId(),user.getUserName(),user.getUserEmail() );</span><br><span class="line"><span class="comment">//        System.out.println(&quot;token &quot;+token);</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(LOGIN_TOKEN_KEY, token,LOGIN_TOKEN_TTL, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;登录成功:数据库密码是：&quot;+user.getUserpwd());</span></span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,<span class="string">&quot;登录成功&quot;</span>,token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-7、返回token信息"><a href="#2-7、返回token信息" class="headerlink" title="2.7、返回token信息"></a>2.7、返回token信息</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410094100233.png" alt="image-20230410094100233"></p><h3 id="2-8、token解析"><a href="#2-8、token解析" class="headerlink" title="2.8、token解析"></a>2.8、token解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestJwtVerify</span><span class="params">()</span>&#123;</span><br><span class="line">    String token=<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.&quot;</span> +</span><br><span class="line">            <span class="string">&quot;eyJ1c2VyTmFtZSI6InRlc3REZW1vIiwiZXhwIjoxNjgxMDkxMDY2LCJ1c2VySWQiOjE0LCJlbWFpbCI6IjE1ODY0ODg1MjRAcXEuY29tIn0.&quot;</span> +</span><br><span class="line">            <span class="string">&quot;5Q71TB78lkhWsTBE0BENR1h8uTZCITsYxPDyAgugvy8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> JWTUtils.getUser(token);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410094523640.png" alt="image-20230410094523640"></p><p>到此，完结。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot-邮件注册登录（qq邮箱）</title>
      <link href="/2023/04/10/Springboot-%E9%82%AE%E4%BB%B6%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%EF%BC%88qq%E9%82%AE%E7%AE%B1%EF%BC%89/"/>
      <url>/2023/04/10/Springboot-%E9%82%AE%E4%BB%B6%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%EF%BC%88qq%E9%82%AE%E7%AE%B1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot-邮件注册登录（qq邮箱）"><a href="#Springboot-邮件注册登录（qq邮箱）" class="headerlink" title="Springboot-邮件注册登录（qq邮箱）"></a>Springboot-邮件注册登录（qq邮箱）</h1><h2 id="1、登录注册思路"><a href="#1、登录注册思路" class="headerlink" title="1、登录注册思路"></a>1、登录注册思路</h2><blockquote><p>这是一个使用Springboot做的一个QQ邮箱注册和登录项目。没有写前端页面，使用postman测试，有详细截图。</p></blockquote><h3 id="1-1-、思路"><a href="#1-1-、思路" class="headerlink" title="1.1 、思路"></a>1.1 、思路</h3><p>注册：通过输入的邮箱发送验证码，检验前端传来的验证码是否和后台生成的一致，若一致，将数据写入数据库，完成注册；</p><p>登录：通过输入的邮箱查询密码，然后比较密码是否一致，一致就是登录成功。</p><h2 id="2、准备"><a href="#2、准备" class="headerlink" title="2、准备"></a>2、准备</h2><h3 id="2-1、开启邮箱POP3-x2F-SMTP服务"><a href="#2-1、开启邮箱POP3-x2F-SMTP服务" class="headerlink" title="2.1、开启邮箱POP3&#x2F;SMTP服务"></a>2.1、开启邮箱POP3&#x2F;SMTP服务</h3><p>登录QQ邮箱，点击左上方的设置，选择账户，如下图。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/20201206203542757.png" alt="在这里插入图片描述"></p><p>然后一直往下滑，看到如下图的<strong>POP3&#x2F;SMTP服务</strong>，点击开启，应该会让帮定的手机号发个短信，然后会收到一个授权码，<code>一定要好好保存</code>，在appliction.<a href="https://so.csdn.net/so/search?q=properties&spm=1001.2101.3001.7020">properties</a>(appliction.yaml)配置中会用到。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/20201206183100240.png" alt="在这里插入图片描述"></p><h3 id="2-2、创建springboot项目"><a href="#2-2、创建springboot项目" class="headerlink" title="2.2、创建springboot项目"></a>2.2、创建springboot项目</h3><p>下边是pom.xml中<code>&lt;dependencies&gt;</code>标签的全部依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3、application-yaml配置文件"><a href="#2-3、application-yaml配置文件" class="headerlink" title="2.3、application.yaml配置文件"></a>2.3、application.yaml配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#  应用名称</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ForumSystem</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yu0804</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/bbsforum?characterEncoding=utf-8&amp;severTimezone=UTC</span></span><br><span class="line"><span class="comment">#qq邮箱配置</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span>  <span class="comment">#平台地址，这里用的是qq邮箱，使用其他邮箱请更换</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">1586488524</span><span class="string">@qq.com</span>   <span class="comment">#邮箱登陆用户名。</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">khhpvqcquavdbaaf</span>    <span class="comment">#第三方登陆授权码</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">utf-8</span></span><br></pre></td></tr></table></figure><h3 id="2-4、创建数据库"><a href="#2-4、创建数据库" class="headerlink" title="2.4、创建数据库"></a>2.4、创建数据库</h3><p>数据库结构如下图</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410084510648.png" alt="image-20230410084510648"></p><h2 id="3、全部代码类"><a href="#3、全部代码类" class="headerlink" title="3、全部代码类"></a>3、全部代码类</h2><h3 id="3-1、User实体"><a href="#3-1、User实体" class="headerlink" title="3.1、User实体"></a>3.1、User实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(value =&quot;users&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span><span class="comment">//自增</span></span><br><span class="line"><span class="comment">//    @TableId(type = IdType.ASSIGN_ID)//雪花算法uuid</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头像ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Avatars userAvatarid;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userEmail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2邮箱发送验证码工具类"><a href="#3-2邮箱发送验证码工具类" class="headerlink" title="3.2邮箱发送验证码工具类"></a>3.2邮箱发送验证码工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023/3/8 20:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;<span class="comment">//一定要用@Autowired</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate RedisTemplate;</span><br><span class="line">    <span class="comment">//application.properties中已配置的值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给前端输入的邮箱，发送验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMimeMail</span><span class="params">( String email)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成随机数（验证码）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> randomCode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存验证码到 session   timeout参数值单位是s      //这里是将email作为key存入redis,确保code不错乱</span></span><br><span class="line">            RedisTemplate.opsForValue().set(REGISTER_CODE_KEY + email, code, REGISTER_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">//这里是用Redis的string结构来存的，后面如果考虑到优化性能的话可以考虑使用hash来存</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将随机数放置到session中</span></span><br><span class="line"><span class="comment">//            session.setAttribute(&quot;email&quot;,email);</span></span><br><span class="line"><span class="comment">//            session.setAttribute(&quot;code&quot;,code);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">SimpleMailMessage</span> <span class="variable">mailMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line"></span><br><span class="line">            mailMessage.setSubject(<span class="string">&quot;Forum论坛注册验证码邮件&quot;</span>);<span class="comment">//主题</span></span><br><span class="line"></span><br><span class="line">            mailMessage.setText(<span class="string">&quot;&lt;div style=\&quot;max-width:600px ; margin: 5px auto ; background: #ffffff; padding: 2rem; border:1px solid #eeeeee; box-shadow: 0.3rem 0.3rem 0.3rem #ccc \&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;你好&lt;br&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;感谢注册Forum论坛，你的注册验证码（请于 15 分钟内使用）\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;br&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;b style=\&quot;color: #946CE6;font-size: 48px\&quot;&gt;&quot;</span>+code+<span class="string">&quot;&lt;/b&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;br&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;br&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;small style=\&quot;color:gray;\&quot;&gt;如果这不是你的请求，请忽略此邮件。&lt;/small&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;br&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; &lt;/div&gt;&quot;</span>);</span><br><span class="line">            mailMessage.setTo(email);<span class="comment">//发给谁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            mailMessage.setFrom(from);//你自己的邮箱</span></span><br><span class="line">            mailMessage.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MimeUtility.encodeText(<span class="string">&quot;Forum Team&quot;</span>)+<span class="string">&quot;&lt;1586488524@qq.com&gt;&quot;</span>).toString());<span class="comment">//自定义邮箱发件人名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            mailSender.send(mailMessage);<span class="comment">//发送</span></span><br><span class="line">            log.info(<span class="string">&quot;code: &quot;</span>+code);</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成6位数的验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            str.append(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里邮件文本格式可参考<a href="%5Bhttps://yuydot.gitee.io/2023/03/31/Springboot%E4%B9%8B%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/%5D(https://yuydot.gitee.io/2023/03/31/Springboot%E4%B9%8B%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/)">Spring boot之发送5种不同格式的邮件</a></p><h3 id="3-3-UserService-使用mybatisPlus方便之处，不用写mapper"><a href="#3-3-UserService-使用mybatisPlus方便之处，不用写mapper" class="headerlink" title="3.3 UserService(使用mybatisPlus方便之处，不用写mapper)"></a>3.3 UserService(使用mybatisPlus方便之处，不用写mapper)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UsersMapper, Users&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UsersService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UsersMapper usersMapper;<span class="comment">//注入UserMapper，交给bean</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册： 检验验证码是否一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">registered</span><span class="params">(RegisterVO userVo)</span> &#123;</span><br><span class="line">        String email=userVo.getEmail();</span><br><span class="line">        <span class="keyword">if</span> (!RegexUtils.isEmailInvalid(email)) &#123;</span><br><span class="line">            <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;邮箱格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取Redis中的验证信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(REGISTER_CODE_KEY+email);</span><br><span class="line">        System.out.println(<span class="string">&quot;catchCode&quot;</span>+cacheCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取表单中的提交的验证信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">voCode</span> <span class="operator">=</span> userVo.getCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果email数据为空，或者不一致，注册失败</span></span><br><span class="line">        <span class="keyword">if</span> (email == <span class="literal">null</span> || email.isEmpty() || !email.equals(userVo.getEmail()))&#123;</span><br><span class="line">            <span class="comment">//return &quot;error,请重新注册&quot;;</span></span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;邮箱不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(voCode)) &#123;</span><br><span class="line">            <span class="comment">// 不一致，报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对密码进行MD5加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userPwd</span> <span class="operator">=</span> userVo.getPassword();</span><br><span class="line">        userVo.setPassword(CommonUtils.MD5(userPwd));</span><br><span class="line">        System.out.println(userVo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存数据</span></span><br><span class="line">        <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> MapStructs.INSTANCE.toUser(userVo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据写入数据库</span></span><br><span class="line">        usersMapper.insert(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳转成功页面</span></span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录：通过输入email查询password，然后比较两个password，如果一样，登录成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginVO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">loginIn</span><span class="params">(LoginVO loginVO)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginEmail</span> <span class="operator">=</span> loginVO.getEmail();</span><br><span class="line">        <span class="keyword">if</span> (!RegexUtils.isEmailInvalid(loginEmail)) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;输入的邮箱格式不对&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;输入的邮箱格式不对&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;Users&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> usersMapper.selectOne(queryWrapper.eq(Users::getUserEmail, loginVO.getEmail()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">Pwd</span> <span class="operator">=</span> CommonUtils.MD5(loginVO.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!user.getUserPassword().equals(Pwd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.buildResult(Result.Status.INTERNAL_SERVER_ERROR,<span class="string">&quot;密码不正确&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWTUtils.getJwtToken(user.getUserId(),user.getUserName(),user.getUserEmail() );</span><br><span class="line"><span class="comment">//        System.out.println(&quot;token &quot;+token);</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(LOGIN_TOKEN_KEY, token,LOGIN_TOKEN_TTL, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;登录成功:数据库密码是：&quot;+user.getUserpwd());</span></span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,<span class="string">&quot;登录成功&quot;</span>,token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4Controller层"><a href="#3-4Controller层" class="headerlink" title="3.4Controller层"></a>3.4Controller层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MailUtil mailUtil; <span class="comment">//用来发送验证码邮件</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UsersService usersService;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送验证码</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendEmail&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendEmail</span><span class="params">(String email)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.buildResult(Result.Status.OK,mailUtil.sendMimeMail(email));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//注册</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(RegisterVO registerVO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usersService.registered(registerVO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登录</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginVO loginVO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usersService.loginIn(loginVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Postman测试"><a href="#4、Postman测试" class="headerlink" title="4、Postman测试"></a>4、Postman测试</h2><h3 id="4-1、测试发送邮件"><a href="#4-1、测试发送邮件" class="headerlink" title="4.1、测试发送邮件"></a>4.1、测试发送邮件</h3><p><strong>请求url：</strong><a href="http://localhost:8088//sendEmail?email=1586488524@qq.com">http://localhost:8088//sendEmail?email=1586488524@qq.com</a></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410090107920.png" alt="image-20230410090107920"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410090107920.png"></p><h3 id="4-2、测试注册"><a href="#4-2、测试注册" class="headerlink" title="4.2、测试注册"></a>4.2、测试注册</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410091249892.png" alt="image-20230410091249892"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410091316705.png" alt="image-20230410091316705"></p><h3 id="4-3、测试登录"><a href="#4-3、测试登录" class="headerlink" title="4.3、测试登录"></a>4.3、测试登录</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230410091554724.png" alt="image-20230410091554724"></p><h2 id="5、最后"><a href="#5、最后" class="headerlink" title="5、最后"></a>5、最后</h2><h3 id="5-1、该邮件发送是在毕业设计课程的一个论坛项目中用到的，详细代码参考Gof-4论坛"><a href="#5-1、该邮件发送是在毕业设计课程的一个论坛项目中用到的，详细代码参考Gof-4论坛" class="headerlink" title="5.1、该邮件发送是在毕业设计课程的一个论坛项目中用到的，详细代码参考Gof-4论坛"></a>5.1、该邮件发送是在毕业设计课程的一个论坛项目中用到的，详细代码参考<a href="https://gitee.com/Yuydot/forum-system">Gof-4论坛</a></h3><h3 id="5-2在登录和注册过程中，使用了redis作为session缓存验证码和用户信息，用户登录后使用了JWT返回token信息。"><a href="#5-2在登录和注册过程中，使用了redis作为session缓存验证码和用户信息，用户登录后使用了JWT返回token信息。" class="headerlink" title="5.2在登录和注册过程中，使用了redis作为session缓存验证码和用户信息，用户登录后使用了JWT返回token信息。"></a>5.2在登录和注册过程中，使用了redis作为session缓存验证码和用户信息，用户登录后使用了JWT返回token信息。</h3>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解WebSocket</title>
      <link href="/2023/04/04/%E4%BA%86%E8%A7%A3WebSocket/"/>
      <url>/2023/04/04/%E4%BA%86%E8%A7%A3WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="了解WebSocket"><a href="#了解WebSocket" class="headerlink" title="了解WebSocket"></a>了解WebSocket</h2><p>更详细了解：</p><ul><li><a href="https://www.jianshu.com/p/964cef2359e7">WebSocket详解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket API</a></li></ul><h3 id="一、什么是WebSocket"><a href="#一、什么是WebSocket" class="headerlink" title="一、什么是WebSocket?"></a>一、什么是WebSocket?</h3><ul><li>WebSocket是一种在单个<a href="https://so.csdn.net/so/search?q=TCP%E8%BF%9E%E6%8E%A5&spm=1001.2101.3001.7020">TCP连接</a>上进行全双工通信的协议，它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。</li><li>WebSocket使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。</li><li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以<code>创建持久性的连接，并进行双向数据传输</code>。</li><li>WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议），Websocket是一个<strong>持久化</strong>的协议。</li></ul><p>WebSocket原理：</p><ul><li>websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信</li><li>在websocket出现之前，web交互一般是基于http协议的短连接或者长连接</li><li>websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”</li></ul><h3 id="二、WebSocket能做什么？"><a href="#二、WebSocket能做什么？" class="headerlink" title="二、WebSocket能做什么？"></a>二、WebSocket能做什么？</h3><p>利用双向数据传输的特点可以用来完成很多功能，不需要前端<a href="https://so.csdn.net/so/search?q=%E8%BD%AE%E8%AF%A2&spm=1001.2101.3001.7020">轮询</a>，浪费资源。例如：</p><ul><li><p>通告功能</p></li><li><p>聊天功能 （如下是逻辑图）</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/db8583eeb0864e3d945003463e780160.png"></p></li><li><p>实时更新数据功能</p></li><li><p>弹幕</p></li></ul><p>等等 …….</p><h3 id="三、为什么用WebSocket"><a href="#三、为什么用WebSocket" class="headerlink" title="三、为什么用WebSocket?"></a>三、为什么用WebSocket?</h3><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：<em><strong>通信只能由客户端发起</strong></em>，HTTP 协议做不到服务器主动向客户端推送信息。</p><blockquote><p>http是一种无状态，无连接，单向的应用层协议，它采用了请求&#x2F;响应模型，通信请求只能由客户端发起，服务端对请求做出应答处理。这样的弊端显然是很大的，只要服务端状态连续变化，客户端就必须实时响应，都是通过javascript与ajax进行轮询，这样显然是非常麻烦的，同时轮询的效率低，非常的浪费资源(http一直打开，一直重复的连接)。</p></blockquote><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/20180510223926952.png"></p><p>​举例来说，我们想要查询当前的排队情况，只能是页面轮询向服务器发出请求，服务器返回查询结果。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><p>​而WebSocket可以更好做到这一点。它的最大特点就是，<strong>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话</strong>，属于服务器推送技术的一种。</p><p>简单理解：</p><ol><li>HTTP 打电话：<br>我问一句<br>你回答一句<br>没有提问就没有回答，即便对方主动给你说话，我也是个聋子听不见</li><li>WebSocket 打电话：<br>双向对话</li></ol><h3 id="四、websocket与http的关系"><a href="#四、websocket与http的关系" class="headerlink" title="四、websocket与http的关系"></a>四、websocket与http的关系</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/45259e81df6b4455bdcfcad460a3a8bf.png"></p><blockquote><p><strong>相同点：</strong></p><ol><li><strong>都是基于tcp的，都是可靠性传输协议</strong></li><li><strong>都是应用层协议</strong></li></ol></blockquote><blockquote><p><strong>不同点：</strong></p><ol><li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li><li><strong>HTTP是单向的</strong></li><li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li><li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li></ol></blockquote><blockquote><p><strong>联系：</strong></p><ul><li><strong>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的</strong></li></ul></blockquote><blockquote><p><strong>总结（总体过程）：</strong></p><ol><li><strong>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；</strong></li><li><strong>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；</strong></li><li><strong>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。</strong></li></ol></blockquote><h3 id="五、websocket解决的问题"><a href="#五、websocket解决的问题" class="headerlink" title="五、websocket解决的问题"></a>五、websocket解决的问题</h3><h4 id="1-http存在的问题"><a href="#1-http存在的问题" class="headerlink" title="1.http存在的问题"></a>1.http存在的问题</h4><ul><li>http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才进行相应的响应，因此本身对于实时通讯就是一种极大的障碍</li><li>http协议采用一次请求，一次响应，每次请求和响应就携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下</li><li>最重要的是，需要客户端主动发，服务端被动发，也就是一次请求，一次响应，不能实现主动发送</li></ul><h4 id="2-long-poll-长轮询"><a href="#2-long-poll-长轮询" class="headerlink" title="2.long poll(长轮询)"></a>2.long poll(长轮询)</h4><ul><li>对于以上情况就出现了http解决的第一个方法——长轮询</li><li>基于http的特性，简单点说，就是客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询</li><li>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，实现了“伪·长连接”</li><li>张三取快递的例子，张三今天一定要取到快递，他就一直站在快递点，等待快递一到，立马取走</li></ul><blockquote><p>从例子上来看有个问题：</p><ol><li>假如有好多人一起在快递站等快递，那么这个地方是否足够大，（抽象解释：需要有很高的并发，同时有很多请求等待在这里）</li></ol></blockquote><p>总的来看：</p><ul><li>推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。</li><li>服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。</li></ul><h4 id="3-Ajax轮询"><a href="#3-Ajax轮询" class="headerlink" title="3.Ajax轮询"></a>3.Ajax轮询</h4><ul><li>基于http的特性，简单点说，就是规定每隔一段时间就由客户端发起一次请求，查询有没有新消息，如果有，就返回，如果没有等待相同的时间间隔再次询问</li><li>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，把这个过程放大n倍，本质上还是request &#x3D; response</li><li>举个形象的例子（假设张三今天有个快递快到了，但是张三忍耐不住，就每隔十分钟给快递员或者快递站打电话，询问快递到了没，每次快递员就说还没到，等到下午张三的快递到了，but，快递员不知道哪个电话是张三的，（可不是只有张三打电话，还有李四，王五），所以只能等张三打电话，才能通知他，你的快递到了）</li></ul><blockquote><p> 从例子上来看有两个问题：</p><ol><li>假如说，张三打电话的时间间隔为10分钟，当他收到快递前最后一次打电话，快递员说没到，他刚挂掉电话，快递入库了（就是到了），那么等下一次时间到了，张三打电话知道快递到了，那么这样的通讯算不算实时通讯？很显然，不算，中间有十分钟的时间差，还不算给快递员打电话的等待时间（抽象的解释：每次request的请求时间间隔等同于十分钟，请求解析相当于等待）</li><li>假如说张三所在的小区每天要收很多快递，每个人都采取主动给快递员打电话的方式，那么快递员需要以多快的速度接到，其他人打电话占线也是问题（抽象解释：请求过多，服务端响应也会变慢）</li></ol></blockquote><p>总的来看，Ajax轮询存在的问题：</p><ul><li>推送延迟。</li><li>服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。</li><li>推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高</li></ul><h3 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h3><ol><li>事件</li></ol><p>​      <strong>@ServerEndpoint这个注解用来标记一个类是 WebSocket 的处理器。</strong></p><ul><li>Open(@onOpen)：服务器响应websocket的请求会触发</li><li>Message(@onMessage)：当消息被接收时会触发</li><li>Close(@onClose)：当连接关闭时会触发，关闭之后，服务端和客户端就不能发消息了</li><li>Error(@onError)：发生错误会触发，并会告诉你错误的原因</li></ul><ol start="2"><li>方法</li></ol><ul><li>send()：一旦服务器与客户端建立连接(open)之后，就可以使用其发送消息了，发送的消息都是二进制格式的</li><li>close(): 关闭连接</li></ul><ol start="3"><li>属性</li></ol><p>（1）readyState：WebSocket通过readyState（只读）来传达连接状态，它会随着连接状态的改变而改变，由四个值来表示：</p><ul><li>WebSocket.CONNECTING &#x3D; 0 ：连接正在进行</li><li>WebSocket.OPEN &#x3D; 1 ：连接已经建立</li><li>WebSocket.CLOSING &#x3D; 2 ：连接正在进行关闭握手</li><li>WebSocket.CLOSED &#x3D; 3 ：连接已经关闭</li></ul><p> （2）bufferedAmount：用于检查已经进入队列但还未传输的数据大小  </p><p> （3） Protocol：Protocol让服务到知道客户端使用WebSocket的协议，两者使用的协议不同的话，整个属性都是空的。</p><p>​       </p>]]></content>
      
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 使用WebSocket打造在线聊天室</title>
      <link href="/2023/04/04/SpringBoot-%E4%BD%BF%E7%94%A8WebSocket%E6%89%93%E9%80%A0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
      <url>/2023/04/04/SpringBoot-%E4%BD%BF%E7%94%A8WebSocket%E6%89%93%E9%80%A0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot 使用WebSocket打造在线聊天室（基于注解）</p><blockquote><p>推荐WebSocket的三大理由：</p><ul><li>1、采用全双工通信，摆脱传统HTTP轮询的窘境。</li><li>2、采用W3C国际标准，完美支持HTML5。</li><li>3、简单高效，容易上手。</li></ul></blockquote><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>快速学会通过WebSocket编写简单聊天功能。</p><h2 id="快速查阅"><a href="#快速查阅" class="headerlink" title="快速查阅"></a>快速查阅</h2><p>专题阅读：<a href="https://www.jianshu.com/p/964370d9374e">《SpringBoot 布道系列》</a></p><p>源码下载：<a href="https://links.jianshu.com/go?to=https://github.com/yizhiwazi/springboot-socks/tree/master/springboot-websocket-chat">SpringBoot-WebSocket-Chat</a></p><blockquote><p>1、WebSocket是<a href="https://so.csdn.net/so/search?q=HTML5&spm=1001.2101.3001.7020">HTML5</a>开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。<br>2、浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。<br>3、当你获取 Web <a href="https://so.csdn.net/so/search?q=Socket&spm=1001.2101.3001.7020">Socket</a> 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。</p></blockquote><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="一、打造-WebSocket-聊天客户端"><a href="#一、打造-WebSocket-聊天客户端" class="headerlink" title="一、打造 WebSocket 聊天客户端"></a>一、打造 WebSocket 聊天客户端</h3><blockquote><p>温馨提示：得益于W3C国际标准的实现，我们在浏览器JS就能直接创建WebSocket对象，再通过简单的回调函数就能完成WebSocket客户端的编写，非常简单！接下来让我们一探究竟。</p></blockquote><h4 id="使用步骤：1、获取WebSocket客户端对象。"><a href="#使用步骤：1、获取WebSocket客户端对象。" class="headerlink" title="使用步骤：1、获取WebSocket客户端对象。"></a>使用步骤：1、获取WebSocket客户端对象。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： var webSocket = new WebSocket(url);</span><br></pre></td></tr></table></figure><h4 id="使用步骤：2、获取WebSocket回调函数。"><a href="#使用步骤：2、获取WebSocket回调函数。" class="headerlink" title="使用步骤：2、获取WebSocket回调函数。"></a>使用步骤：2、获取WebSocket回调函数。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：webSocket.onmessage = function (event) &#123;console.log(&#x27;WebSocket收到消息：&#x27; + event.data);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">事件类型</th><th align="left">WebSocket回调函数</th><th align="left">事件描述</th></tr></thead><tbody><tr><td align="center">open</td><td align="left">webSocket.onopen</td><td align="left">当打开连接后触发</td></tr><tr><td align="center">message</td><td align="left">webSocket.onmessage</td><td align="left">当客户端接收服务端数据时触发</td></tr><tr><td align="center">error</td><td align="left">webSocket.onerror</td><td align="left">当通信异常时触发</td></tr><tr><td align="center">close</td><td align="left">webSocket.onclose</td><td align="left">当连接关闭时触发</td></tr></tbody></table><h4 id="使用步骤：3、发送消息给服务端"><a href="#使用步骤：3、发送消息给服务端" class="headerlink" title="使用步骤：3、发送消息给服务端"></a>使用步骤：3、发送消息给服务端</h4><p><code>例如：webSokcet.send(jsonStr)</code> 结合实际场景 本案例采用JSON字符串进行消息通信。</p><h4 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h4><p>下面是本案例在线聊天的客户端实现的JS代码，附带详细注释。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * WebSocket客户端</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     *</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 使用说明：</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 1、WebSocket客户端通过回调函数来接收服务端消息。例如：webSocket.onmessage</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 2、WebSocket客户端通过send方法来发送消息给服务端。例如：webSocket.send();</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getWebSocket</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * WebSocket客户端 PS：URL开头表示WebSocket协议 中间是域名端口 结尾是服务端映射地址</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> webSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/chat&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * 当服务端打开连接</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        webSocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket打开连接&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * 当服务端发来消息：1.广播消息 2.更新在线人数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        webSocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket收到消息：%c&#x27;</span> + event.<span class="property">data</span>, <span class="string">&#x27;color:green&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//获取服务端消息</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>) || &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $messageContainer = $(<span class="string">&#x27;.message-container&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//喉咙发炎</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (message.<span class="property">type</span> === <span class="string">&#x27;SPEAK&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $messageContainer.<span class="title function_">append</span>(</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;&lt;div class=&quot;mdui-card&quot; style=&quot;margin: 10px 0;&quot;&gt;&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;&lt;div class=&quot;mdui-card-primary&quot;&gt;&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;&lt;div class=&quot;mdui-card-content message-content&quot;&gt;&#x27;</span> + message.<span class="property">username</span> + <span class="string">&quot;：&quot;</span> + message.<span class="property">msg</span> + <span class="string">&#x27;&lt;/div&gt;&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                    <span class="string">&#x27;&lt;/div&gt;&lt;/div&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&#x27;.chat-num&#x27;</span>).<span class="title function_">text</span>(message.<span class="property">onlineCount</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//防止刷屏</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $cards = $messageContainer.<span class="title function_">children</span>(<span class="string">&#x27;.mdui-card:visible&#x27;</span>).<span class="title function_">toArray</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> ($cards.<span class="property">length</span> &gt; <span class="number">5</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $cards.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    index &lt; $cards.<span class="property">length</span> - <span class="number">5</span> &amp;&amp; $(item).<span class="title function_">slideUp</span>(<span class="string">&#x27;fast&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * 关闭连接</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        webSocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket关闭连接&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * 通信失败</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        webSocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket发生异常&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> webSocket;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> webSocket = <span class="title function_">getWebSocket</span>();</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 通过WebSocket对象发送消息给服务端</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendMsgToServer</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> $message = $(<span class="string">&#x27;#msg&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> ($message.<span class="title function_">val</span>()) &#123;</span></span><br><span class="line"><span class="language-javascript">            webSocket.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">username</span>: $(<span class="string">&#x27;#username&#x27;</span>).<span class="title function_">text</span>(), <span class="attr">msg</span>: $message.<span class="title function_">val</span>()&#125;));</span></span><br><span class="line"><span class="language-javascript">            $message.<span class="title function_">val</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 清屏</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">clearMsg</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&quot;.message-container&quot;</span>).<span class="title function_">empty</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 使用ENTER发送消息</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> e = event || <span class="variable language_">window</span>.<span class="property">event</span> || <span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>.<span class="property">arguments</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        e.<span class="property">keyCode</span> === <span class="number">13</span> &amp;&amp; <span class="title function_">sendMsgToServer</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h3 id="二、打造-WebSocket-聊天服务端"><a href="#二、打造-WebSocket-聊天服务端" class="headerlink" title="二、打造 WebSocket 聊天服务端"></a>二、打造 WebSocket 聊天服务端</h3><blockquote><p>温馨提示：得益于SpringBoot提供的自动配置，我们只需要通过简单注解<code>@ServerEndpoint</code>就就能创建WebSocket服务端，再通过简单的回调函数就能完成WebSocket服务端的编写，比起客户端的使用同样非常简单！</p></blockquote><h4 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h4><p>首先在POM文件引入<code>spring-boot-starter-websocket</code> 、thymeleaf 、FastJson等依赖。</p><h4 id="使用步骤：1、开启WebSocket服务端的自动注册。"><a href="#使用步骤：1、开启WebSocket服务端的自动注册。" class="headerlink" title="使用步骤：1、开启WebSocket服务端的自动注册。"></a>使用步骤：1、开启WebSocket服务端的自动注册。</h4><p>【<code>这里需要特别提醒：ServerEndpointExporter 是由Spring官方提供的标准实现，用于扫描ServerEndpointConfig配置类和@ServerEndpoint注解实例。使用规则也很简单：1.如果使用默认的嵌入式容器 比如Tomcat 则必须手工在上下文提供ServerEndpointExporter。2. 如果使用外部容器部署war包，则不要提供提供ServerEndpointExporter，因为此时SpringBoot默认将扫描服务端的行为交给外部容器处理。</code>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用步骤：2、创建WebSocket服务端。"><a href="#使用步骤：2、创建WebSocket服务端。" class="headerlink" title="使用步骤：2、创建WebSocket服务端。"></a>使用步骤：2、创建WebSocket服务端。</h4><p>核心思路：</p><ul><li>① 通过注解<code>@ServerEndpoint</code>来声明实例化WebSocket服务端。</li><li>② 通过注解<code>@OnOpen、@OnMessage、@OnClose、@OnError</code> 来声明回调函数。</li></ul><table><thead><tr><th align="center">事件类型</th><th align="left">WebSocket服务端注解</th><th align="left">事件描述</th></tr></thead><tbody><tr><td align="center">open</td><td align="left">@OnOpen</td><td align="left">当打开连接后触发</td></tr><tr><td align="center">message</td><td align="left">@OnMessage</td><td align="left">当客户端接收服务端数据时触发</td></tr><tr><td align="center">error</td><td align="left">@OnClose</td><td align="left">当通信异常时触发</td></tr><tr><td align="center">close</td><td align="left">@OnError</td><td align="left">当连接关闭时触发</td></tr></tbody></table><ul><li>③ 通过<code>ConcurrentHashMap</code>保存全部在线会话对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span><span class="comment">//标记此类为服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketChatServer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全部在线会话  PS: 基于场景考虑 这里使用线程安全的Map存储会话对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; onlineSessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端打开连接：1.添加会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        onlineSessions.put(session.getId(), session);</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.ENTER, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端发送消息：1.获取它的用户名和消息 2.发送消息给所有人</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * PS: 这里约定传递的消息为JSON字符串 方便传递更多参数！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String jsonStr)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> JSON.parseObject(jsonStr, Message.class);</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.SPEAK, message.getUsername(), message.getMsg(), onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当关闭连接：1.移除会话对象 2.更新在线人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        onlineSessions.remove(session.getId());</span><br><span class="line">        sendMessageToAll(Message.jsonStr(Message.QUIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;下线了！&quot;</span>, onlineSessions.size()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信发生异常：打印错误日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共方法：发送信息给所有人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessageToAll</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        onlineSessions.forEach((id, session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>④ 通过会话对象 <code>javax.websocket.Session</code> 来发消息给客户端。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 聊天消息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.hehe.chat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 聊天消息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ENTER</span> <span class="operator">=</span> <span class="string">&quot;ENTER&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPEAK</span> <span class="operator">=</span> <span class="string">&quot;SPEAK&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUIT</span> <span class="operator">=</span> <span class="string">&quot;QUIT&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//消息类型</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//发送人</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//发送消息</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> onlineCount; <span class="comment">//在线用户数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">jsonStr</span><span class="params">(String type, String username, String msg, <span class="type">int</span> onlineTotal)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(<span class="keyword">new</span> <span class="title class_">Message</span>(type, username, msg, onlineTotal));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(String type, String username, String msg, <span class="type">int</span> onlineCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.onlineCount = onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这里省略get/set方法 请自行补充</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="三、WebSocket在线聊天案例的视频演示"><a href="#三、WebSocket在线聊天案例的视频演示" class="headerlink" title="三、WebSocket在线聊天案例的视频演示"></a>三、WebSocket在线聊天案例的视频演示</h3><ol><li><p>源码下载</p><p>至此，我们完成了客户端和服务端的编码，由于篇幅有限，本教程的页面代码并未完整贴上，想要完整的体验效果请在Github下载源码。传送门：<a href="https://links.jianshu.com/go?to=https://github.com/yizhiwazi/springboot-socks/tree/master/springboot-websocket-chat">springboot-websocket-chat</a></p></li><li><p>视频演示</p></li></ol><p>上面一顿操作猛如虎，实际到底是啥样子呢，接下来由哈士奇童鞋为我们演示最终版的在线聊天案例：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/8069210-5ad9f1cdaf8d2a64.webp"></p><h3 id="四、全文总结"><a href="#四、全文总结" class="headerlink" title="四、全文总结"></a>四、全文总结</h3><ol><li>使用WebSocket用于实时双向通讯的场景，常见的如聊天室、跨系统消息推送等。</li><li>创建WebSocket客户端使用JS内置对象+回调函数+send方法发送消息。</li><li>创建WebSocket服务端使用注解声明实例+使用注解声明回调方法+使用Session发送消息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot之Redis工具类</title>
      <link href="/2023/03/31/Springboot%E4%B9%8BRedis%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2023/03/31/Springboot%E4%B9%8BRedis%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>文章转载：<a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">出处</a></p><p> SpringBoot整合Redis的博客很多，但是很多都不是我想要的结果。因为我只需要整合完成后，可以操作Redis就可以了，并不需要配合缓存相关的注解使用（如@Cacheable）。看了很多博客后，我成功的整合了，并写了个Redis操作工具类。特意在此记录一下，方便后续查阅。</p><h2 id="一、Maven依赖"><a href="#一、Maven依赖" class="headerlink" title="一、Maven依赖"></a>一、Maven依赖</h2><h5 id="（1）本文所采用的SpringBoot的版本如下"><a href="#（1）本文所采用的SpringBoot的版本如下" class="headerlink" title="（1）本文所采用的SpringBoot的版本如下"></a>（1）本文所采用的SpringBoot的版本如下</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="（2）加入Redis相关依赖"><a href="#（2）加入Redis相关依赖" class="headerlink" title="（2）加入Redis相关依赖"></a>（2）加入Redis相关依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="二、application-properties中加入redis相关配置"><a href="#二、application-properties中加入redis相关配置" class="headerlink" title="二、application.properties中加入redis相关配置"></a>二、application.properties中加入redis相关配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis数据库索引（默认为0）  </span></span><br><span class="line">spring.redis.database=<span class="number">0</span>  </span><br><span class="line"><span class="comment"># Redis服务器地址  </span></span><br><span class="line">spring.redis.host=<span class="number">192.168</span><span class="number">.0</span><span class="number">.24</span>  </span><br><span class="line"><span class="comment"># Redis服务器连接端口  </span></span><br><span class="line">spring.redis.port=<span class="number">6379</span>  </span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）  </span></span><br><span class="line">spring.redis.password=  </span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）  </span></span><br><span class="line">spring.redis.pool.<span class="built_in">max</span>-active=<span class="number">200</span>  </span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）  </span></span><br><span class="line">spring.redis.pool.<span class="built_in">max</span>-wait=-<span class="number">1</span>  </span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接  </span></span><br><span class="line">spring.redis.pool.<span class="built_in">max</span>-idle=<span class="number">10</span> </span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接  </span></span><br><span class="line">spring.redis.pool.<span class="built_in">min</span>-idle=<span class="number">0</span>  </span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）  </span></span><br><span class="line">spring.redis.timeout=<span class="number">1000</span> </span><br></pre></td></tr></table></figure><h2 id="三、写一个redis配置类"><a href="#三、写一个redis配置类" class="headerlink" title="三、写一个redis配置类"></a>三、写一个redis配置类</h2><h5 id="（1）聊聊RedisTemplate的自动配置"><a href="#（1）聊聊RedisTemplate的自动配置" class="headerlink" title="（1）聊聊RedisTemplate的自动配置"></a>（1）聊聊RedisTemplate的自动配置</h5><p>​    其实现在就可以在代码中注入RedisTemplate，为啥可以直接注入呢？先看下源码吧。下图为 RedisAutoConfiguration类中的截图，为了防止图片失效，代码也贴上 。</p><p>​    <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/1222688-20180711162915486-1128650164.png" alt="img"></p><p>​    代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(</span></span><br><span class="line"><span class="params">RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line"><span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。</strong>但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。</p><p>​    看到这个**@ConditionalOnMissingBean<strong>注解后，就知道</strong>如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化**。因此我们可以直接自己写个配置类，配置RedisTemplate。</p><h5 id="（2）既然自动配置不好用，就重新配置一个RedisTemplate"><a href="#（2）既然自动配置不好用，就重新配置一个RedisTemplate" class="headerlink" title="（2）既然自动配置不好用，就重新配置一个RedisTemplate"></a>（2）既然自动配置不好用，就重新配置一个RedisTemplate</h5><p>​    代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">zxy</span>.<span class="property">demo</span>.<span class="property">redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">context</span>.<span class="property">annotation</span>.<span class="property">Bean</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">context</span>.<span class="property">annotation</span>.<span class="property">Configuration</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">data</span>.<span class="property">redis</span>.<span class="property">connection</span>.<span class="property">RedisConnectionFactory</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">data</span>.<span class="property">redis</span>.<span class="property">core</span>.<span class="property">RedisTemplate</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">data</span>.<span class="property">redis</span>.<span class="property">serializer</span>.<span class="property">Jackson2JsonRedisSerializer</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">data</span>.<span class="property">redis</span>.<span class="property">serializer</span>.<span class="property">StringRedisSerializer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.<span class="property">fasterxml</span>.<span class="property">jackson</span>.<span class="property">annotation</span>.<span class="property">JsonAutoDetect</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">fasterxml</span>.<span class="property">jackson</span>.<span class="property">annotation</span>.<span class="property">PropertyAccessor</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">fasterxml</span>.<span class="property">jackson</span>.<span class="property">databind</span>.<span class="property">ObjectMapper</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZENG.XIAO.YAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>   2018年6月6日</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">RedisTemplate</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; <span class="title function_">redisTemplate</span>(<span class="params">RedisConnectionFactory factory</span>) &#123;</span><br><span class="line">    <span class="title class_">RedisTemplate</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt;();</span><br><span class="line">    template.<span class="title function_">setConnectionFactory</span>(factory);</span><br><span class="line"><span class="title class_">Jackson2JsonRedisSerializer</span> jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(<span class="title class_">Object</span>.<span class="property">class</span>);</span><br><span class="line">        <span class="title class_">ObjectMapper</span> om = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.<span class="title function_">setVisibility</span>(<span class="title class_">PropertyAccessor</span>.<span class="property">ALL</span>, <span class="title class_">JsonAutoDetect</span>.<span class="property">Visibility</span>.<span class="property">ANY</span>);</span><br><span class="line">        om.<span class="title function_">enableDefaultTyping</span>(<span class="title class_">ObjectMapper</span>.<span class="property">DefaultTyping</span>.<span class="property">NON_FINAL</span>);</span><br><span class="line">        jackson2JsonRedisSerializer.<span class="title function_">setObjectMapper</span>(om);</span><br><span class="line">        <span class="title class_">StringRedisSerializer</span> stringRedisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.<span class="title function_">setKeySerializer</span>(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.<span class="title function_">setHashKeySerializer</span>(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.<span class="title function_">setValueSerializer</span>(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.<span class="title function_">setHashValueSerializer</span>(jackson2JsonRedisSerializer);</span><br><span class="line">        template.<span class="title function_">afterPropertiesSet</span>();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、写一个Redis工具类"><a href="#四、写一个Redis工具类" class="headerlink" title="四、写一个Redis工具类"></a>四、写一个Redis工具类</h2><p>​    直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。</p><p>​    工具类代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxy.demo.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.<span class="keyword">data</span>.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZENG.XIAO.YAN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>   2018年6月7日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================common============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定缓存失效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean expire(String key, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long getExpire(String key) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hasKey(String key) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> void del(String... key) &#123;</span><br><span class="line"><span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================String=============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存获取</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="keyword">get</span>(String key) &#123;</span><br><span class="line"><span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().<span class="keyword">get</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存放入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean <span class="keyword">set</span>(String key, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForValue().<span class="keyword">set</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean <span class="keyword">set</span>(String key, Object value, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">redisTemplate.opsForValue().<span class="keyword">set</span>(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">set</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递增</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long incr(String key, long delta) &#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long decr(String key, long delta) &#123;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================================Map=================================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashGet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object hget(String key, String item) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().<span class="keyword">get</span>(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Object, Object&gt; hmget(String key) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet 并设置时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">expire(key, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hset(String key, String item, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hset(String key, String item, Object value, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">expire(key, time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除hash表中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> void hdel(String key, Object... item) &#123;</span><br><span class="line">redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean hHasKey(String key, String item) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> double hincr(String key, String item, double <span class="keyword">by</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, <span class="keyword">by</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> double hdecr(String key, String item, double <span class="keyword">by</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -<span class="keyword">by</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============================set=============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; sGet(String key) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean sHasKey(String key, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据放入set缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long sSet(String key, Object... values) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将set数据放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long sSetAndTime(String key, long time, Object... values) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Long</span> count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取set缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long sGetSetSize(String key) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除值为value的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long setRemove(String key, Object... values) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Long</span> count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取list缓存的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; lGet(String key, long start, long end) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取list缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long lGetListSize(String key) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object lGetIndex(String key, long index) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean lSet(String key, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean lSet(String key, Object value, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean lSet(String key, List&lt;Object&gt; value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">expire(key, time);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> boolean lUpdateIndex(String key, long index, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">redisTemplate.opsForList().<span class="keyword">set</span>(key, index, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除N个值为value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long lRemove(String key, long count, Object value) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">Long</span> remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line"><span class="keyword">return</span> remove;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>​    整合其实不麻烦，网上好多博文都有。注意设置下key和value的序列化方式，不然存到Redis的中数据看起来像乱码一下。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot之不同格式的邮件</title>
      <link href="/2023/03/31/Springboot%E4%B9%8B%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/"/>
      <url>/2023/03/31/Springboot%E4%B9%8B%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot之发送5种不同格式的邮件"><a href="#Spring-boot之发送5种不同格式的邮件" class="headerlink" title="Spring boot之发送5种不同格式的邮件"></a>Spring boot之发送5种不同格式的邮件</h2><p><strong>Spring boot之邮件发送</strong><br>Spring Boot中发送邮件使用的是Spring提供的org.springframework.mail.javamail.JavaMailSender，其提供了许多简单易用的方法，可发送简单的邮件、HTML格式的邮件、带附件的邮件，并且可以创建邮件模板。</p><p>引入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>邮件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="comment"># 配置 SMTP 服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="comment"># 发送者邮箱</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">XXX@163.com</span></span><br><span class="line">    <span class="comment"># 配置密码，注意不是真正的密码，而是刚刚申请到的授权码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">JIZDEI555PKDZSVOTZQ</span></span><br><span class="line">    <span class="comment"># 端口号:465或者994</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtps</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="comment"># 表示开启 DEBUG 模式</span></span><br><span class="line">        <span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">socketFactoryClass:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送简单的邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/email&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender jms;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendSimpleEmail&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendSimpleEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">            message.setFrom(from);</span><br><span class="line">            <span class="comment">// 接收地址</span></span><br><span class="line">            message.setTo(<span class="string">&quot;XXX@onmicrosoft.com&quot;</span>);</span><br><span class="line">            <span class="comment">// 标题</span></span><br><span class="line">            message.setSubject(<span class="string">&quot;一封简单的邮件&quot;</span>);</span><br><span class="line">            <span class="comment">// 内容</span></span><br><span class="line">            message.setText(<span class="string">&quot;使用Spring Boot发送简单邮件。&quot;</span>);</span><br><span class="line">            jms.send(message);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;发送成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送HTML格式的邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;sendHtmlEmail&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">sendHtmlEmail</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         message = jms.createMimeMessage();</span><br><span class="line">         <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">         helper.setFrom(from);</span><br><span class="line">         helper.setTo(<span class="string">&quot;XXX@onmicrosoft.com&quot;</span>);</span><br><span class="line">         helper.setSubject(<span class="string">&quot;一封HTML格式的邮件&quot;</span>);</span><br><span class="line">         <span class="comment">// 带HTML格式的内容</span></span><br><span class="line">         <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&lt;p style=&#x27;color:#42b983&#x27;&gt;使用Spring Boot发送HTML格式邮件。&lt;/p&gt;&quot;</span>);</span><br><span class="line">         helper.setText(sb.toString(), <span class="literal">true</span>);</span><br><span class="line">         jms.send(message);</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;发送成功&quot;</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span> e.getMessage();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发送带附件的邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;sendAttachmentsMail&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">sendAttachmentsMail</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           message = jms.createMimeMessage();</span><br><span class="line">           <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">           helper.setFrom(from);</span><br><span class="line">           helper.setTo(<span class="string">&quot;XXX@onmicrosoft.com&quot;</span>);</span><br><span class="line">           helper.setSubject(<span class="string">&quot;一封带附件的邮件&quot;</span>);</span><br><span class="line">           helper.setText(<span class="string">&quot;详情参见附件内容！&quot;</span>);</span><br><span class="line">           <span class="comment">// 传入附件</span></span><br><span class="line">           <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> ResourceUtils.getFile(<span class="string">&quot;classpath:static/file/附件.docx&quot;</span>);</span><br><span class="line">           helper.addAttachment(<span class="string">&quot;附件.docx&quot;</span>, file);</span><br><span class="line">           jms.send(message);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;发送成功&quot;</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> e.getMessage();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发送带静态资源的邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;sendInlineMail&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">sendInlineMail</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         message = jms.createMimeMessage();</span><br><span class="line">         <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">         helper.setFrom(from);</span><br><span class="line">         helper.setTo(<span class="string">&quot;XXX@onmicrosoft.com&quot;</span>);</span><br><span class="line">         helper.setSubject(<span class="string">&quot;一封带静态资源的邮件&quot;</span>); <span class="comment">// 标题</span></span><br><span class="line">         helper.setText(<span class="string">&quot;&lt;html&gt;&lt;body&gt;图片：&lt;img src=&#x27;cid:img&#x27;/&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">         <span class="comment">// 传入附件</span></span><br><span class="line">         <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> ResourceUtils.getFile(<span class="string">&quot;classpath:static/img/img.png&quot;</span>);</span><br><span class="line">         helper.addInline(<span class="string">&quot;img&quot;</span>, file);</span><br><span class="line">         jms.send(message);</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;发送成功&quot;</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span> e.getMessage();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用模板发送邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span> xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;模板&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    您好，您的验证码为&lt;span th:text=<span class="string">&quot;$&#123;code&#125;&quot;</span>&gt;&lt;/span&gt;，请在两分钟内使用完成操作。</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;sendTemplateEmail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sendTemplateEmail</span><span class="params">(String code)</span> &#123;</span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        message = jms.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(<span class="string">&quot;XXX@onmicrosoft.com&quot;</span>); <span class="comment">// 接收地址</span></span><br><span class="line">        helper.setSubject(<span class="string">&quot;邮件摸板测试&quot;</span>); <span class="comment">// 标题</span></span><br><span class="line">        <span class="comment">// 处理邮件模板</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;emailTemplate&quot;</span>, context);</span><br><span class="line">        helper.setText(template, <span class="literal">true</span>);</span><br><span class="line">        jms.send(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;发送成功&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录(SSO)</title>
      <link href="/2023/03/31/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO/"/>
      <url>/2023/03/31/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是单点登录？"><a href="#一、什么是单点登录？" class="headerlink" title="一、什么是单点登录？"></a>一、什么是单点登录？</h3><p> 单点登录的英文名叫做：Single Sign On（简称SSO）。</p><p>在初学&#x2F;以前的时候，一般我们就单系统，所有的功能都在同一个系统上。</p><p>后来，我们为了合理利用资源和降低耦合性，于是把单系统拆分成多个子系统。</p><p>回顾：分布式基础知识</p><p>​    比如阿里系的淘宝和天猫，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p>​    简单来说，单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。</p><h3 id="二、回顾单系统登录"><a href="#二、回顾单系统登录" class="headerlink" title="二、回顾单系统登录"></a>二、回顾单系统登录</h3><pre><code> 在我初学JavaWeb的时候，登录和注册是我做得最多的一个功能了（初学Servlet的时候做过、学SpringMVC的时候做过、跟着做项目的时候做过…），反正我也数不清我做了多少次登录和注册的功能了…这里简单讲述一下我们初学时是怎么做登录功能的。</code></pre><p>​    众所周知，HTTP是无状态的协议，这意味着服务器无法确认用户的信息。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie。</p><p>​    如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。Session相当于在服务器中建立了一份“客户明细表”。</p><p>​    HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。其实Session是依据Cookie来识别是否是同一个用户。</p><p>所以，一般我们单系统实现登录会这样做：</p><ul><li>登录：将用户信息保存在Session对象中</li><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li><li>注销（退出登录）：从Session中删除用户的信息</li><li>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）：配合Cookie来用</li></ul><p>我之前Demo的代码，可以参考一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用户登陆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(value = “/user/session”, produces = &#123;“application/json;charset=UTF-8”&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(String mobileNo, String password, String inputCaptcha, HttpSession session, HttpServletResponse response)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断验证码是否正确</span></span><br><span class="line"><span class="keyword">if</span> (WebUtils.validateCaptcha(inputCaptcha, “captcha”, session)) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断有没有该用户</span></span><br><span class="line"> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.userLogin(mobileNo, password);</span><br><span class="line"> <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">/*设置自动登陆，一个星期.  将token保存在数据库中*/</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">loginToken</span> <span class="operator">=</span> WebUtils.md5(<span class="keyword">new</span> <span class="title class_">Date</span>().toString() + session.getId());</span><br><span class="line">     user.setLoginToken(loginToken);</span><br><span class="line">     <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userService.userUpload(user);</span><br><span class="line"></span><br><span class="line">     session.setAttribute(<span class="string">&quot;user&quot;</span>, user1);</span><br><span class="line"></span><br><span class="line">     CookieUtil.addCookie(response,<span class="string">&quot;loginToken&quot;</span>,loginToken,<span class="number">604800</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ResultUtil.success(user1);</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ResultUtil.error(ResultEnum.LOGIN_ERROR);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ResultUtil.error(ResultEnum.CAPTCHA_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用户退出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@DeleteMapping(value = “/session”, produces = &#123;“application/json;charset=UTF-8”&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">logout</span><span class="params">(HttpSession session,HttpServletRequest request,HttpServletResponse response )</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除session和cookie</span></span><br><span class="line">session.removeAttribute(“user”);</span><br><span class="line"></span><br><span class="line">CookieUtil.clearCookie(request, response, “loginToken”);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ResultUtil.success();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> ozc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">拦截器；实现自动登陆功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">sessionUser</span> <span class="operator">=</span> (User) request.getSession().getAttribute(“user”);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经登陆了，放行</span></span><br><span class="line"><span class="keyword">if</span> (sessionUser != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//得到带过来cookie是否存在</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">loginToken</span> <span class="operator">=</span> CookieUtil.findCookieByName(request, <span class="string">&quot;loginToken&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(loginToken)) &#123;</span><br><span class="line">        <span class="comment">//到数据库查询有没有该Cookie</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserByLoginToken(loginToken);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有该Cookie与之对应的用户(Cookie不匹配)</span></span><br><span class="line">            CookieUtil.clearCookie(request, response, <span class="string">&quot;loginToken&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有cookie、也没有登陆。是index请求获取用户信息，可以放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;session&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有cookie凭证</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 总结一下上面代码的思路：</p><ul><li>用户登录时，验证用户的账户和密码</li><li>生成一个Token保存在数据库中，将Token写到Cookie中</li><li>将用户数据保存在Session中</li><li>请求时都会带上Cookie，检查有没有登录，如果已经登录则放行</li></ul><p>如果没看懂的同学，建议回顾Session和Cookie和HTTP：</p><p>介绍会话技术、Cookie的API、详解、应用<br> Session介绍、API、生命周期、应用、与Cookie区别<br> 什么是HTTP</p><h3 id="三、多系统登录的问题与解决"><a href="#三、多系统登录的问题与解决" class="headerlink" title="三、多系统登录的问题与解决"></a>三、多系统登录的问题与解决</h3><p> <strong>3.1 Session不共享问题</strong><br>     单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是不共享的。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/fc0a1daba95448a1a23405c976fa79ac.png" alt="img"></p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</li><li>根据请求的IP进行Hash映射到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</li><li>把Session数据放在Redis中（使用Redis模拟Session）【建议】</li><li>如果还不了解Redis的同学，建议移步（Redis合集）</li><li>我们可以将登录功能单独抽取出来，做成一个子系统。</li></ul><p>SSO（登录系统）的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录功能(SSO单独的服务)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> TaotaoResult <span class="title function_">login</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">    <span class="type">TbUserExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbUserExample</span>();</span><br><span class="line">    <span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> example.createCriteria();</span><br><span class="line">    criteria.andUsernameEqualTo(username);</span><br><span class="line">    List&lt;TbUser&gt; list = userMapper.selectByExample(example);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == list || list.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> TaotaoResult.build(<span class="number">400</span>, <span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核对密码</span></span><br><span class="line">    <span class="type">TbUser</span> <span class="variable">user</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!DigestUtils.md5DigestAsHex(password.getBytes()).equals(user.getPassword())) &#123;</span><br><span class="line">        <span class="keyword">return</span> TaotaoResult.build(<span class="number">400</span>, <span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登录成功，把用户信息写入redis</span></span><br><span class="line">    <span class="comment">//生成一个用户token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    jedisCluster.set(USER_TOKEN_KEY + <span class="string">&quot;:&quot;</span> + token, JsonUtils.objectToJson(user));</span><br><span class="line">    <span class="comment">//设置session过期时间</span></span><br><span class="line">    jedisCluster.expire(USER_TOKEN_KEY + <span class="string">&quot;:&quot;</span> + token, SESSION_EXPIRE_TIME);</span><br><span class="line">    <span class="keyword">return</span> TaotaoResult.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><pre><code> 其他子系统登录时，请求SSO（登录系统）进行登录，将返回的token写到Cookie中，下次访问时则把Cookie带上：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TaotaoResult <span class="title function_">login</span><span class="params">(String username, String password,</span></span><br><span class="line"><span class="params">HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//请求参数</span></span><br><span class="line">    Map&lt;String, String&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    param.put(“username”, username);</span><br><span class="line">    param.put(“password”, password);</span><br><span class="line">    <span class="comment">//登录处理</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">stringResult</span> <span class="operator">=</span> HttpClientUtil.doPost(REGISTER_USER_URL + USER_LOGIN_URL, param);</span><br><span class="line">    <span class="type">TaotaoResult</span> <span class="variable">result</span> <span class="operator">=</span> TaotaoResult.format(stringResult);</span><br><span class="line">    <span class="comment">//登录出错</span></span><br><span class="line">    <span class="keyword">if</span> (result.getStatus() != <span class="number">200</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//登录成功后把取token信息，并写入cookie</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> (String) result.getData();</span><br><span class="line">    <span class="comment">//写入cookie</span></span><br><span class="line">    CookieUtils.setCookie(request, response, “TT_TOKEN”, token);</span><br><span class="line">    <span class="comment">//返回成功</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 总结：</p><ul><li>SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间</li><li>其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中</li><li>每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录</li></ul><p>到这里，其实我们会发现其实就两个变化：</p><ul><li>将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录</li><li>本来将用户信息存到Session，现在将用户信息存到Redis</li></ul><p> <strong>3.2 Cookie跨域的问题</strong><br>     上面我们解决了Session不能共享的问题，但其实还有另一个问题。Cookie是不能跨域的</p><p>比如说，我们请求<a href="https://www.google.com/%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%8Agoogle.com%E7%9A%84Cookie%E5%B8%A6%E8%BF%87%E5%8E%BB%E7%BB%99google%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BC%9A%E6%8A%8Ahttps://www.baidu.com/%E7%9A%84Cookie%E5%B8%A6%E8%BF%87%E5%8E%BB%E7%BB%99google%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">https://www.google.com/时，浏览器会自动把google.com的Cookie带过去给google的服务器，而不会把https://www.baidu.com/的Cookie带过去给google的服务器。</a></p><p>这就意味着，由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><p>​    服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了<br>​     多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。<br>​     将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）<br>​     到这里，我们已经可以实现单点登录了。</p><p><strong>3.3 CAS原理</strong><br>     说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。</p><p>​    如果已经将登录单独抽取成系统出来，我们还能这样玩。现在我们有两个系统，分别是<a href="http://www.java3y.com和www.java4y.com,一个ssowww.sso.com/">www.java3y.com和www.java4y.com，一个SSOwww.sso.com</a></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/9a6fa1bb04ad473c944e44c50450c587.png" alt="img"></p><p>​    首先，用户想要访问系统A<a href="http://www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p><p><a href="http://www.sso.com/?service=www.java3y.com">www.sso.com?service=www.java3y.com</a><br>     sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/5c0f6464d676441c828ffdef920d43fe.png" alt="img"></p><p>​    随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：</p><p><a href="http://www.java3y.com/?token=xxxxxxx">www.java3y.com?token=xxxxxxx</a><br>     接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/34a9c874c5e04502b9f83c372ea89724.png" alt="在这里插入图片描述"></p><p>​    此时，用户想要访问系统B<a href="http://www.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统Bwww.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统Bwww.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p><p><a href="http://www.sso.com/?service=www.java4y.com">www.sso.com?service=www.java4y.com</a><br> 注意，因为之前用户与认证中心<a href="http://www.sso.com已经建立了全局会话(当时已经把cookie保存到浏览器上了),所以这次系统b重定向到认证中心www.sso.com是可以带上cookie的./">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。</a></p><p>​    认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下：</p><p><a href="http://www.java4y.com/?token=xxxxxxx">www.java4y.com?token=xxxxxxx</a><br>     接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/5bd0466ec61a4f0f8449503bd6ee30d4.png" alt="在这里插入图片描述"></p><p>看到这里，其实SSO认证中心就类似一个中转站。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitee简单使用</title>
      <link href="/2023/03/31/Gitee%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/31/Gitee%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><p>查看不同级别的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看系统config</span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line">#查看当前用户（global）配置</span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>设置用户名与邮箱（用户标识，必要）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;kuangshen&quot;  #名称</span><br><span class="line">git config --global user.email 24736743@qq.com   #邮箱</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>克隆远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 查看文件状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># git add .                  添加所有文件到暂存区</span><br><span class="line"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line"></span><br><span class="line">#文件的四种状态：</span><br><span class="line"></span><br><span class="line">版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</span><br><span class="line"></span><br><span class="line">Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</span><br><span class="line"></span><br><span class="line">Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</span><br><span class="line"></span><br><span class="line">Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</span><br><span class="line"></span><br><span class="line">Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>git分支中常用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以 <a href="%5B(148%E6%9D%A1%E6%B6%88%E6%81%AF">参考</a> 如何将本地代码上传到 gitee_上传代码到gitee_海绵宝宝不喜欢侬的博客-CSDN博客](<a href="https://blog.csdn.net/m0_58953167/article/details/127894206?ops_request_misc=%7B%22request_id%22:%22168191237016800213034121%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168191237016800213034121&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-127894206-null-null.142%5Ev85%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%A6%82%E4%BD%95%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0gitee&spm=1018.2226.3001.4187">https://blog.csdn.net/m0_58953167/article/details/127894206?ops_request_misc=%7B%22request%5Fid%22%3A%22168191237016800213034121%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168191237016800213034121&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-127894206-null-null.142^v85^koosearch_v1,239^v2^insert_chatgpt&amp;utm_term=如何将代码上传到gitee&amp;spm=1018.2226.3001.4187</a>))</p><h1 id="一、将项目托管到gitee"><a href="#一、将项目托管到gitee" class="headerlink" title="一、将项目托管到gitee"></a>一、将项目托管到gitee</h1><h2 id="1、注册用户、建库（略）"><a href="#1、注册用户、建库（略）" class="headerlink" title="1、注册用户、建库（略）"></a>1、注册用户、建库（略）</h2><h2 id="2、下载Git-for-windows工具"><a href="#2、下载Git-for-windows工具" class="headerlink" title="2、下载Git for windows工具"></a>2、下载Git for windows工具</h2><h2 id="3、桌面右击打开Git-Bash"><a href="#3、桌面右击打开Git-Bash" class="headerlink" title="3、桌面右击打开Git Bash"></a>3、桌面右击打开Git Bash</h2><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/965f328612834d8a86049f5d451b699f.png" alt="img"></p><p> 命令和Linux差不多</p><p>找到要托管的代码文件（直接到代码文件右击打开git bash）</p><p>（1）先新建Gitee仓库，克隆仓库到本地</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419214351008.png" alt="image-20230419214351008"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419214456271.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> （2）把要托管的文件夹传到刚下载的文件夹里(或者直接将要托管的文件拖到刚克隆的文件夹下)</p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419214748476.png" alt="image-20230419214748476"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r 需要托管的文件夹  克隆生成的文件夹</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（3）Git的工作原理</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/0b3073d899e54077b4e7793c5fcb3ea0.png" alt="img"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwME5KNEw5T1BJOWlhMU1taWJwdkRkNmNTZGRCZHZybGJkRXR5RU9yaDRDS25XVmlieWZDSGEzbHpYdy82NDA.png"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p><strong>工作流程</strong><br> git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。 </p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwMDlpYU9obDBkQUNmTHJNd05iRHp1Y0dRMzBzM0huc2lhY3pmY1I2ZEM5T2VoaWN1d2liS3VIalJsemcvNjQw.png"></p><p>如图：我们将工作区代码上传到Romote，需要经历几个步骤 </p><p><strong>a. 放到暂存区</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419220331534.png" alt="image-20230419220331534"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>b. 放到本地版本库</strong></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20230419220438487.png" alt="image-20230419220438487"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提示信息，随便输入&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 可能还需要配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;自定义用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br><span class="line"></span><br><span class="line">查：</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <strong>c. push到master</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="二、多人协作开发流程"><a href="#二、多人协作开发流程" class="headerlink" title="二、多人协作开发流程"></a>二、多人协作开发流程</h1><ul><li>邀请多人开发</li><li>每人对各种的开发功能创建分支</li><li>合并他人分支并上传到自己分支</li></ul><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/2b1d18303ce747abb34941c231ad7d38.png" alt="img"></p><p>feature是普通开发人员分支</p><p>master和develop为保护分支，不允许普通开发人员合并和上传分支，由管理员管理</p><p> 查看当前用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/5617467af9354916a9a1bf250691c56f.png" alt="img"></p><p>查看分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/60bede1cea484382804a893aba6b644f.png" alt="img"></p><p>（1）个人分支： 用户选择一个自己的分支（将自己要写的部分项目写到自己的分支里，后面在合并）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#现在比如说，我们需要stangtang-txt写一个stangtang.txt文件（相当于是切换到stangtang-txt分支，然后写代码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1、切换分支（创建并切换）</span><br><span class="line">git checkout -b stangtang-txt  </span><br><span class="line"></span><br><span class="line">#2、写文件 </span><br><span class="line">vim stangtang.txt</span><br><span class="line"></span><br><span class="line">#3、将项目从工作区加入到环境区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">#4、从暂存区提交到本地库</span><br><span class="line">git commit -m &quot;提一次提交&quot;</span><br><span class="line"></span><br><span class="line">#5. push分支</span><br><span class="line">git push origin stangtang-txt</span><br><span class="line"></span><br><span class="line">#6.最后由管理员合并</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后查看分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/a28231ddeb334f4c845b0ca7ce73a095.png" alt="img"></p><p>解决冲突：用户同时修改统一（一个是只在gitee项目中修改，另一个在gitee bash上修改）分支内容，这时会有冲突（gitee bash上修改后提交失败）</p><p>解决：</p><p><strong>a. 在gitee bash上修改时，先要将修改的分支拉下来（pull）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin stangtang-txt</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/c253ee0774c047309074a261cefd6eb1.png" alt="img"></p><p>b. 然后在修改内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim stangtang.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#后面操作相同</span><br><span class="line"></span><br><span class="line">#3、将项目从工作区加入到环境区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">#4、从暂存区提交到本地库</span><br><span class="line">git commit -m &quot;冲突解决了&quot;</span><br><span class="line"></span><br><span class="line">#5. push分支</span><br><span class="line">git push origin stangtang-txt</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（2）合并分支</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/5a793cd9c662405696c40acb30d900fd.png" alt="img"></p><p> a. 管理员pull分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin stangtang-txt</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6aa2d06f6e594efaaf8ca802516b5db5.png" alt="img"></p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/9fd4bc265cf147a18fc62ad6dce8442d.png" alt="img"></p><p> 我们可以看到stangtang-txt直接合并到master里面了</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>（1）在gitee建立仓库</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/a7339c38d9a846d9bafceb4c92f9bfea.png" alt="img"></p><p>（2）在项目保存地址打开Git Bash</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/4574482612804344b991912a595dd3fb.png" alt="img"></p><p>（3）复制地址，克隆</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/b4fb16a6b77341739511716a0b11cfa0.png" alt="img"></p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/06f98f6aaba34fe38c6529f5e606df25.png" alt="img"></p><p>（4）将需要托管的项目文件拷贝到刚下载的文件夹内（如上图 forum-system）</p><p>（5）进入文件夹，查看分支，创建分支</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/cb40565c641d464ebef372bc066cb39b.png" alt="img"></p><p>（6） 放到暂存区</p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/ef47248810a74a32828d5f1a84bac3fd.png" alt="img"></p><p>（7）放到本地版本库</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/b42212ad0d114c2baaf272a3902d94f9.png" alt="img"></p><p>（8）push到分支</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/f47eaba79f924b54baa7495c0e47c759.png" alt="img"></p><p>到此结束………………………………</p><hr><h2 id="更新代码后"><a href="#更新代码后" class="headerlink" title="更新代码后"></a>更新代码后</h2><p> （1）在项目内点击Git Bash</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6ff920286ab9495e9df2595b761e37ec.png" alt="img"></p><p>（2）将本地仓库中的文件推送至远程仓库中（分支）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin feature/forum-user</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/d7bfe023c94a42c8bb372fc2d6e27353.png" alt="img"></p><p> （3）添加项目目录下所有文件至本地仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/615edf1927dd412ba34101bb6148c3e1.png" alt="img"></p><p> （4）使用如下命令加入注释提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &quot;备注&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> <img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/d448221146244e12928eaa9434ce1e0b.png" alt="img"></p><p> （5）提交代码，更新远程仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin eature/forum-user</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/91c6b4a4f04d4f8f96d01060d8ccd5cd.png" alt="img"></p><p> 到此结束…………….</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/ce88ec580d4840eca1a2d5be20420dc3.png" alt="img"></p><p>最后，最后，最后的总结：  在使用gitee托管项目时，团队开发我们应该注意建立分支。成员根据自己的开发任务建立自己的分支来托管代码，最后再由仓库管理员进行分支合并。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3S3N1OFVsSVR3TWxiWDNrTUd0WjlwMEJPR3phRzRRVGM0SlhPMGhTbHdjTnR1ak56QXZ4ZWliU3JhakxZTENUNm90Tm5IRFY5eFlXd0EvNjQw.png"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/20230406132418.png"></p><h3 id="本地仓库搭建："><a href="#本地仓库搭建：" class="headerlink" title="本地仓库搭建："></a>本地仓库搭建：</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h3 id="克隆远程仓库："><a href="#克隆远程仓库：" class="headerlink" title="克隆远程仓库："></a>克隆远程仓库：</h3><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 2、去 gitee 或者 github 上克隆一个测试！</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT详解</title>
      <link href="/2023/03/31/JWT%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/03/31/JWT%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文某博客搬运，原文格式更加美观，可以移步原文阅读：<a href="https://baobao555.tech/archives/40">JWT详解</a></p><h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><h3 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1.什么是JWT"></a>1.什么是JWT</h3><p>在介绍JWT之前，我们先来回顾一下利用<code>token</code>进行用户身份验证的流程：</p><ol><li>客户端使用用户名和密码请求登录</li><li>服务端收到请求，验证用户名和密码</li><li>验证成功后，服务端会签发一个<code>token</code>，再把这个<code>token</code>返回给客户端</li><li>客户端收到token后可以把它存储起来，比如放到cookie中</li><li>客户端每次向服务端请求资源时需要携带服务端签发的token，可以在<code>cookie</code>或者<code>header</code>中携带</li><li>服务端收到请求，然后去验证客户端请求里面带着的<code>token</code>，如果验证成功，就向客户端返回请求数据</li></ol><p>这种基于<code>token</code>的认证方式相比传统的<code>session</code>认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下：</p><ul><li><strong>支持跨域访问</strong>：<code>cookie</code>是无法跨域的，而<code>token</code>由于没有用到<code>cookie</code>(前提是将<code>token</code>放到请求头中)，所以跨域后不会存在信息丢失问题</li><li><strong>无状态</strong>：<code>token</code>机制在服务端不需要存储<code>session</code>信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力</li><li><strong>更适用CDN</strong>：可以通过内容分发网络请求服务端的所有资料</li><li><strong>更适用于移动端</strong>：当客户端是非浏览器平台时，<code>cookie</code>是不被支持的，此时采用<code>token</code>认证方式会简单很多</li><li><strong>无需考虑CSRF</strong>：由于不再依赖<code>cookie</code>，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御</li></ul><p>而<code>JWT</code>就是上述流程当中<code>token</code>的一种具体实现方式，其全称是<code>JSON Web Token</code>，官网地址：<a href="https://jwt.io/">https://jwt.io/</a></p><p>通俗地说，<strong>JWT的本质就是一个字符串</strong>，它是将用户信息保存到一个Json字符串中，然后进行编码后得到一个<code>JWT token</code>，<strong>并且这个<code>JWT token</code>带有签名信息，接收后可以校验是否被篡改</strong>，所以可以用于在各方之间安全地将信息作为Json对象传输。JWT的认证流程如下：</p><ol><li>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口，这个过程一般是一个<code>POST</code>请求。建议的方式是通过SSL加密的传输(HTTPS)，从而避免敏感信息被嗅探</li><li>后端核对用户名和密码成功后，<strong>将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名</strong>，形成一个<code>JWT Token</code>，形成的<code>JWT Token</code>就是一个如同<code>lll.zzz.xxx</code>的字符串</li><li>后端将<code>JWT Token</code>字符串作为登录成功的结果返回给前端。前端可以将返回的结果保存在浏览器中，退出登录时删除保存的<code>JWT Token</code>即可</li><li><strong>前端在每次请求时将<code>JWT Token</code>放入HTTP请求头中的<code>Authorization</code>属性中</strong>(解决XSS和XSRF问题)</li><li>后端检查前端传过来的<code>JWT Token</code>，验证其有效性，比如检查签名是否正确、是否过期、token的接收方是否是自己等等</li><li>验证通过后，后端解析出<code>JWT Token</code>中包含的用户信息，进行其他逻辑操作(一般是根据用户信息得到权限等)，返回结果</li></ol><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/900b3e81f832b2f08c2e8aabb540536a.png" alt="img"></p><h3 id="2-为什么要用JWT"><a href="#2-为什么要用JWT" class="headerlink" title="2.为什么要用JWT"></a>2.为什么要用JWT</h3><h4 id="2-1-传统Session认证的弊端"><a href="#2-1-传统Session认证的弊端" class="headerlink" title="2.1 传统Session认证的弊端"></a>2.1 传统Session认证的弊端</h4><p>我们知道<strong>HTTP本身是一种无状态的协议</strong>，这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，认证通过后HTTP协议不会记录下认证后的状态，那么下一次请求时，用户还要再一次进行认证，因为根据HTTP协议，我们并不知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在用户首次登录成功后，在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为<code>cookie</code>，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这是传统的基于<code>session</code>认证的过程</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/29cfe2cc7bd13bc659227e62c3e89063.png" alt="img"></p><p>然而，传统的<code>session</code>认证有如下的问题：</p><ul><li>每个用户的登录信息都会保存到服务器的<code>session</code>中，<strong>随着用户的增多，服务器开销会明显增大</strong></li><li>由于<code>session</code>是存在与服务器的物理内存中，所以<strong>在分布式系统中，这种方式将会失效</strong>。虽然可以将<code>session</code>统一保存到Redis中，但是这样做无疑增加了系统的复杂性，对于不需要redis的应用也会白白多引入一个缓存中间件</li><li><strong>对于非浏览器的客户端、手机移动端等不适用</strong>，因为<code>session</code>依赖于<code>cookie</code>，而移动端经常没有<code>cookie</code></li><li>因为<code>session</code>认证本质基于<code>cookie</code>，所以如果<code>cookie</code>被截获，用户很容易收到跨站请求伪造攻击。并且如果浏览器禁用了<code>cookie</code>，这种方式也会失效</li><li>前后端分离系统中更加不适用，后端部署复杂，前端发送的请求往往经过多个中间件到达后端，<code>cookie</code>中关于<code>session</code>的信息会转发多次</li><li>由于基于Cookie，而<strong>cookie无法跨域，所以session的认证也无法跨域，对单点登录不适用</strong></li></ul><h4 id="2-2-JWT认证的优势"><a href="#2-2-JWT认证的优势" class="headerlink" title="2.2 JWT认证的优势"></a>2.2 JWT认证的优势</h4><p>对比传统的<code>session</code>认证方式，JWT的优势是：</p><ul><li>简洁：<code>JWT Token</code>数据量小，传输速度也很快</li><li>因为JWT Token是以JSON加密形式保存在客户端的，所以JWT是<strong>跨语言</strong>的，原则上任何web形式都支持</li><li>不需要在服务端保存会话信息，也就是说<strong>不依赖于cookie和session，所以没有了传统session认证的弊端，特别适用于分布式微服务</strong></li><li><strong>单点登录友好</strong>：使用Session进行身份认证的话，由于cookie无法跨域，难以实现单点登录。但是，使用token进行认证的话， <strong>token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依赖cookie</strong>，不会存在这些问题</li><li><strong>适合移动端应用</strong>：使用Session进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie（需要 Cookie 保存 SessionId），所以不适合移动端</li></ul><blockquote><p>因为这些优势，目前无论单体应用还是分布式应用，都更加<strong>推荐用JWT token的方式进行用户认证</strong></p></blockquote><h2 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h2><p>JWT由3部分组成：标头(<a href="https://so.csdn.net/so/search?q=Header&spm=1001.2101.3001.7020">Header</a>)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用<code>.</code>进行连接形成最终传输的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload),secret)JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload),secret)JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload),secret)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/b9cec7cc70df068e7a882b6dcef06299.png" alt="img"></p><h4 id="1-Header"><a href="#1-Header" class="headerlink" title="1.Header"></a>1.Header</h4><p><strong>JWT头</strong>是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-Payload"><a href="#2-Payload" class="headerlink" title="2.Payload"></a>2.Payload</h4><p><strong>有效载荷</strong>部分，是JWT的主体内容部分，也是一个<strong>JSON对象</strong>，包含需要传递的数据。 JWT指定七个默认字段供选择</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss：发行人</span><br><span class="line">exp：到期时间</span><br><span class="line">sub：主题</span><br><span class="line">aud：用户</span><br><span class="line">nbf：在此之前不可用</span><br><span class="line">iat：发布时间</span><br><span class="line">jti：JWT ID用于标识该JWT</span><br></pre></td></tr></table></figure><p>这些预定义的字段并不要求强制使用。除以上默认字段外，我们还可以自定义私有字段，<strong>一般会把包含用户信息的数据放到payload中</strong>，如下例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Helen&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>请注意，<strong>默认情况下JWT是未加密的，因为只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中</strong>，以防止信息泄露。<strong>JWT只是适合在网络中传输一些非敏感的信息</strong></p></blockquote><h4 id="3-Signature"><a href="#3-Signature" class="headerlink" title="3.Signature"></a>3.Signature</h4><p><strong>签名哈希</strong>部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以<strong>确保数据不会被篡改</strong>。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload),secret)HMACSHA256(base64UrlEncode(header)+&quot;.&quot;+base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure><p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用<code>.</code>分隔，就构成整个JWT对象</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/a457f8856a8f8288702ab56b18ed4818.png" alt="img"></p><blockquote><p>注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：</p><ul><li><code>header</code>和<code>payload</code>可以直接利用base64解码出原文，从<code>header</code>中获取哈希签名的算法，从<code>payload</code>中获取有效数据</li><li><code>signature</code>由于使用了不可逆的加密算法，无法解码出原文，它的作用是<strong>校验token有没有被篡改</strong>。服务端获取<code>header</code>中的加密算法之后，利用该算法加上<code>secretKey</code>对<code>header</code>、<code>payload</code>进行加密，比对加密后的数据和客户端发送过来的是否一致。注意<code>secretKey</code>只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，<code>secretKey</code>实际上代表的是盐值</li></ul></blockquote><h2 id="JWT的种类"><a href="#JWT的种类" class="headerlink" title="JWT的种类"></a>JWT的种类</h2><p>其实JWT(JSON Web Token)指的是一种规范，这种规范允许我们使用JWT在两个组织之间传递安全可靠的信息，JWT的具体实现可以分为以下几种：</p><ul><li><code>nonsecure JWT</code>：未经过签名，不安全的JWT</li><li><code>JWS</code>：经过签名的JWT</li><li><code>JWE</code>：<code>payload</code>部分经过加密的JWT</li></ul><h3 id="1-nonsecure-JWT"><a href="#1-nonsecure-JWT" class="headerlink" title="1.nonsecure JWT"></a>1.nonsecure JWT</h3><p>未经过签名，不安全的JWT。其<code>header</code>部分没有指定签名算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>并且也没有<code>Signature</code>部分</p><h4 id="2-JWS"><a href="#2-JWS" class="headerlink" title="2.JWS"></a>2.JWS</h4><p>JWS ，也就是JWT Signature，其结构就是在之前nonsecure JWT的基础上，在头部声明签名算法，并在最后添加上签名。<strong>创建签名，是保证jwt不能被他人随意篡改</strong>。我们通常使用的JWT一般都是JWS</p><p>为了完成签名，除了用到header信息和payload信息外，还需要算法的密钥，也就是<code>secretKey</code>。加密的算法一般有2类：</p><ul><li>对称加密：<code>secretKey</code>指加密密钥，可以生成签名与验签</li><li>非对称加密：<code>secretKey</code>指私钥，只用来生成签名，不能用来验签(验签用的是公钥)</li></ul><p>JWT的密钥或者密钥对，一般统一称为JSON Web Key，也就是<code>JWK</code></p><p>到目前为止，jwt的签名算法有三种：</p><ul><li>HMAC【哈希消息验证码(对称)】：HS256&#x2F;HS384&#x2F;HS512</li><li>RSASSA【RSA签名算法(非对称)】（RS256&#x2F;RS384&#x2F;RS512）</li><li>ECDSA【椭圆曲线数据签名算法(非对称)】（ES256&#x2F;ES384&#x2F;ES512）</li></ul><h2 id="Java中使用JWT"><a href="#Java中使用JWT" class="headerlink" title="Java中使用JWT"></a>Java中使用JWT</h2><p>官网推荐了6个Java使用JWT的开源库，其中比较推荐使用的是<code>java-jwt</code>和<code>jjwt-root</code></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/edf8486457b203795e1a96092c45e729.png" alt="img"></p><h3 id="1-java-jwt"><a href="#1-java-jwt" class="headerlink" title="1.java-jwt"></a>1.java-jwt</h3><h4 id="1-1-对称签名"><a href="#1-1-对称签名" class="headerlink" title="1.1 对称签名"></a>1.1 对称签名</h4><p>首先引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成JWT的token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerateToken</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// 指定token过期时间为10秒</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.SECOND, <span class="number">10</span>);<span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">.withHeader(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())  <span class="comment">// Header</span></span><br><span class="line">.withClaim(<span class="string">&quot;userId&quot;</span>, <span class="number">21</span>)  <span class="comment">// Payload</span></span><br><span class="line">.withClaim(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;baobao&quot;</span>)</span><br><span class="line">.withExpiresAt(calendar.getTime())  <span class="comment">// 过期时间</span></span><br><span class="line">.sign(Algorithm.HMAC256(<span class="string">&quot;!34ADAS&quot;</span>));  <span class="comment">// 签名用的secret</span></span><br><span class="line">System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7f9e01da5fa1badcbde2c1510d5bf646.png" alt="img"></p><blockquote><p>注意<strong>多次运行方法生成的token字符串内容是不一样的</strong>，尽管我们的payload信息没有变动。因为<strong>JWT中携带了超时时间</strong>，所以每次生成的token会不一样，我们利用base64解密工具可以发现payload确实携带了超时时间</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/d0a0bcb4c38af3d86daf07986cfff474.png" alt="img"></p></blockquote><p>解析JWT字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResolveToken</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// 创建解析对象，使用的算法和secret要与创建token时保持一致</span></span><br><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(<span class="string">&quot;!34ADAS&quot;</span>)).build();</span><br><span class="line"><span class="comment">// 解析指定的token</span></span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImJhb2JhbyIsImV4cCI6MTU5OTkyMjUyOCwidXNlcklkIjoyMX0.YhA3kh9KZOAb7om1C7o3vBhYp0f61mhQWWOoCrrhqvo&quot;</span>);</span><br><span class="line"><span class="comment">// 获取解析后的token中的payload信息</span></span><br><span class="line"><span class="type">Claim</span> <span class="variable">userId</span> <span class="operator">=</span> decodedJWT.getClaim(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line"><span class="type">Claim</span> <span class="variable">userName</span> <span class="operator">=</span> decodedJWT.getClaim(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">System.out.println(userId.asInt());</span><br><span class="line">System.out.println(userName.asString());</span><br><span class="line"><span class="comment">// 输出超时时间</span></span><br><span class="line">System.out.println(decodedJWT.getExpiresAt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现报异常，原因是之前生成的token已经过期</p><p><img src="https://img-blog.csdnimg.cn/img_convert/afd36e5f12eb711627189063eb9e350b.png" alt="img"></p><p>再运行一次生成token的方法，然后在过期时间10秒之内将生成的字符串拷贝到解析方法中，运行解析方法即可成功</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f945cb8ab4d030189e776cb8a05b996d.png" alt="img"></p><p>我们可以将上述方法封装成工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtils</span> &#123;</span><br><span class="line"><span class="comment">// 签名密钥</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;!DAR$&quot;</span>;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> payload token携带的信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> token字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getToken</span><span class="params">(Map&lt;String,String&gt; payload)</span>&#123;</span><br><span class="line"><span class="comment">// 指定token过期时间为7天</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"><span class="comment">// 构建payload</span></span><br><span class="line">payload.forEach((k,v) -&gt; builder.withClaim(k,v));</span><br><span class="line"><span class="comment">// 指定过期时间和签名算法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> builder.withExpiresAt(calendar.getTime()).sign(Algorithm.HMAC256(SECRET));</span><br><span class="line"><span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> token token字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 解析后的token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">decode</span><span class="params">(String token)</span>&#123;</span><br><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.HMAC256(SECRET)).build();</span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line"><span class="keyword">return</span> decodedJWT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-非对称签名"><a href="#1-2-非对称签名" class="headerlink" title="1.2 非对称签名"></a>1.2 非对称签名</h4><p>生成jwt串的时候需要指定私钥，解析jwt串的时候需要指定公钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RSA_PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RSA_PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> payload token携带的信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> token字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTokenRsa</span><span class="params">(Map&lt;String,String&gt; payload)</span>&#123;</span><br><span class="line"><span class="comment">// 指定token过期时间为7天</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"><span class="comment">// 构建payload</span></span><br><span class="line">payload.forEach((k,v) -&gt; builder.withClaim(k,v));</span><br><span class="line"><span class="comment">// 利用hutool创建RSA</span></span><br><span class="line"><span class="type">RSA</span> <span class="variable">rsa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSA</span>(RSA_PRIVATE_KEY, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) rsa.getPrivateKey();</span><br><span class="line"><span class="comment">// 签名时传入私钥</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> builder.withExpiresAt(calendar.getTime()).sign(Algorithm.RSA256(<span class="literal">null</span>, privateKey));</span><br><span class="line"><span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解析token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> token token字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 解析后的token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">decodeRsa</span><span class="params">(String token)</span>&#123;</span><br><span class="line"><span class="comment">// 利用hutool创建RSA</span></span><br><span class="line"><span class="type">RSA</span> <span class="variable">rsa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSA</span>(<span class="literal">null</span>, RSA_PUBLIC_KEY);</span><br><span class="line"><span class="comment">// 获取RSA公钥</span></span><br><span class="line"><span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) rsa.getPublicKey();</span><br><span class="line"><span class="comment">// 验签时传入公钥</span></span><br><span class="line"><span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(Algorithm.RSA256(publicKey, <span class="literal">null</span>)).build();</span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line"><span class="keyword">return</span> decodedJWT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-jjwt-root"><a href="#2-jjwt-root" class="headerlink" title="2.jjwt-root"></a>2.jjwt-root</h3><h4 id="2-1-对称签名"><a href="#2-1-对称签名" class="headerlink" title="2.1 对称签名"></a>2.1 对称签名</h4><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用方法类似，可参考下列代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"><span class="comment">// token时效：24小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line"><span class="comment">// 签名哈希的密钥，对于不同的加密算法来说含义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_SECRET</span> <span class="operator">=</span> <span class="string">&quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据用户id和昵称生成token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id  用户id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nickname 用户昵称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> JWT规则生成的token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJwtToken</span><span class="params">(String id, String nickname)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">.setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">.setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">.setSubject(<span class="string">&quot;baobao-user&quot;</span>)</span><br><span class="line">.setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE))</span><br><span class="line">.claim(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">.claim(<span class="string">&quot;nickname&quot;</span>, nickname)</span><br><span class="line"><span class="comment">// HS256算法实际上就是MD5加盐值，此时APP_SECRET就代表盐值</span></span><br><span class="line">.signWith(SignatureAlgorithm.HS256, APP_SECRET)</span><br><span class="line">.compact();</span><br><span class="line"><span class="keyword">return</span> JwtToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果token有效返回true，否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request Http请求对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果token有效返回true，否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 从http请求头中获取token字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据token获取会员id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request Http请求对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 解析token后获得的用户id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMemberIdByJwtToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(jwtToken)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);</span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line"><span class="keyword">return</span> (String)claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>jjwt在0.10版本以后发生了较大变化，pom依赖要引入多个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- or jjwt-gson if Gson is preferred --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>标准规范中对各种加密算法的<code>secretKey</code>的长度有如下要求：</p><ul><li><code>HS256</code>：要求至少 256 bits (32 bytes)</li><li><code>HS384</code>：要求至少384 bits (48 bytes)</li><li><code>HS512</code>：要求至少512 bits (64 bytes)</li><li><code>RS256</code> and <code>PS256</code>：至少2048 bits</li><li><code>RS384</code> and <code>PS384</code>：至少3072 bits</li><li><code>RS512</code> and <code>PS512</code>：至少4096 bits</li><li><code>ES256</code>：至少256 bits (32 bytes)</li><li><code>ES384</code>：至少384 bits (48 bytes)</li><li><code>ES512</code>：至少512 bits (64 bytes)</li></ul><p>在jjwt0.10版本之前，没有强制要求，<code>secretKey</code>长度不满足要求时也可以签名成功。但是0.10版本后强制要求<code>secretKey</code>满足规范中的长度要求，否则生成jws时会抛出异常</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/61313d1173e2126bcf9504035fe88510.png" alt="img"></p></li><li><p>新版本的jjwt中，之前的签名和验签方法都是传入密钥的字符串，已经过时。最新的方法需要传入<code>Key</code>对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"><span class="comment">// token时效：24小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line"><span class="comment">// 签名哈希的密钥，对于不同的加密算法来说含义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APP_SECRET</span> <span class="operator">=</span> <span class="string">&quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHOsdadasdasfdssfeweee&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据用户id和昵称生成token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id  用户id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nickname 用户昵称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> JWT规则生成的token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJwtToken</span><span class="params">(String id, String nickname)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">.setSubject(<span class="string">&quot;baobao-user&quot;</span>)</span><br><span class="line">.setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE))</span><br><span class="line">.claim(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">.claim(<span class="string">&quot;nickname&quot;</span>, nickname)</span><br><span class="line"><span class="comment">// 传入Key对象</span></span><br><span class="line">.signWith(Keys.hmacShaKeyFor(APP_SECRET.getBytes(StandardCharsets.UTF_8)), SignatureAlgorithm.HS256)</span><br><span class="line">.compact();</span><br><span class="line"><span class="keyword">return</span> JwtToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果token有效返回true，否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">decode</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line"><span class="comment">// 传入Key对象</span></span><br><span class="line">Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder().setSigningKey(Keys.hmacShaKeyFor(APP_SECRET.getBytes(StandardCharsets.UTF_8))).build().parseClaimsJws(jwtToken);</span><br><span class="line"><span class="keyword">return</span> claimsJws;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-2-非对称签名"><a href="#2-2-非对称签名" class="headerlink" title="2.2 非对称签名"></a>2.2 非对称签名</h4><p>生成jwt串的时候需要指定私钥，解析jwt串的时候需要指定公钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RSA_PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RSA_PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据用户id和昵称生成token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id  用户id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nickname 用户昵称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> JWT规则生成的token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getJwtTokenRsa</span><span class="params">(String id, String nickname)</span>&#123;</span><br><span class="line"><span class="comment">// 利用hutool创建RSA</span></span><br><span class="line"><span class="type">RSA</span> <span class="variable">rsa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSA</span>(RSA_PRIVATE_KEY, <span class="literal">null</span>);</span><br><span class="line"><span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) rsa.getPrivateKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">JwtToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">.setSubject(<span class="string">&quot;baobao-user&quot;</span>)</span><br><span class="line">.setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE))</span><br><span class="line">.claim(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">.claim(<span class="string">&quot;nickname&quot;</span>, nickname)</span><br><span class="line"><span class="comment">// 签名指定私钥</span></span><br><span class="line">.signWith(privateKey, SignatureAlgorithm.RS256)</span><br><span class="line">.compact();</span><br><span class="line"><span class="keyword">return</span> JwtToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断token是否存在与有效</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jwtToken token字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果token有效返回true，否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">decodeRsa</span><span class="params">(String jwtToken)</span> &#123;</span><br><span class="line"><span class="type">RSA</span> <span class="variable">rsa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSA</span>(<span class="literal">null</span>, RSA_PUBLIC_KEY);</span><br><span class="line"><span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) rsa.getPublicKey();</span><br><span class="line"><span class="comment">// 验签指定公钥</span></span><br><span class="line">Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder().setSigningKey(publicKey).build().parseClaimsJws(jwtToken);</span><br><span class="line"><span class="keyword">return</span> claimsJws;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际开发中的应用"><a href="#实际开发中的应用" class="headerlink" title="实际开发中的应用"></a>实际开发中的应用</h2><p>在实际的<code>SpringBoot</code>项目中，一般我们可以用如下流程做登录：</p><ol><li>在登录验证通过后，给用户生成一个对应的随机token(注意这个token不是指jwt，可以用uuid等算法生成)，然后将这个token作为key的一部分，用户信息作为value存入Redis，并设置过期时间，这个过期时间就是登录失效的时间</li><li>将第1步中生成的随机token作为JWT的payload生成JWT字符串返回给前端</li><li>前端之后每次请求都在请求头中的<code>Authorization</code>字段中携带JWT字符串</li><li>后端定义一个拦截器，每次收到前端请求时，都先从请求头中的<code>Authorization</code>字段中取出JWT字符串并进行验证，验证通过后解析出payload中的随机token，然后再用这个随机token得到key，从Redis中获取用户信息，如果能获取到就说明用户已经登录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">JWT</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.校验JWT字符串</span></span><br><span class="line"><span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> JWTUtils.decode(JWT);</span><br><span class="line"><span class="comment">// 2.取出JWT字符串载荷中的随机token，从Redis中获取用户信息</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (SignatureVerificationException e)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;无效签名&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (TokenExpiredException e)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;token已经过期&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (AlgorithmMismatchException e)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;算法不一致&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;token无效&quot;</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中需要用下列手段来增加JWT的安全性：</p><ul><li>因为JWT是在请求头中传递的，所以为了避免网络劫持，推荐使用<code>HTTPS</code>来传输，更加安全</li><li>JWT的哈希签名的密钥是存放在服务端的，所以只要服务器不被攻破，理论上JWT是安全的。因此要保证服务器的安全</li><li>JWT可以使用暴力穷举来破解，所以为了应对这种破解方式，可以定期更换服务端的哈希签名密钥(相当于盐值)。这样可以保证等破解结果出来了，你的密钥也已经换了</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot入门</title>
      <link href="/2023/03/31/Springboot%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/31/Springboot%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Springboot程序启动"><a href="#Springboot程序启动" class="headerlink" title="Springboot程序启动"></a>Springboot程序启动</h2><h3 id="1-启动的过程"><a href="#1-启动的过程" class="headerlink" title="1.启动的过程"></a>1.启动的过程</h3><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/bb438ddab2374ea099b5dcb06bc79b38.png" alt="img"></p><ul><li>首先在main函数中启动当前应用程序(SpringApplication启动)</li><li>创建SpringApplication对象(new SpringApplication()).在对象的构造方法中进行参数的初始化工作,最主要的是判断当前应用程序的类型以及初始化器和监听器,在此过程中会加载整个应用程序中的spring.factories文件,将文件的内容放在缓存对象中,方便后续获取,具体步骤如下:<ul><li>配置resourceloader</li><li>判断当前应用程序的类型</li><li>获取初始化器的实例对象</li><li>获取监听器的实例对象</li></ul></li><li>找到当前应用程序的主类,开始执行<br>SpringApplication对象创建完成之后开始执行run()方法,来完成整个启动过程.而run方法中主要的步骤如下:<ul><li>设置启动时间</li><li>设置上下文</li><li>设置异常报告器</li><li>创建监听器并从中获取符合监听事件的几个监听器</li><li>配置命令行参数</li><li>准备应用程序运行的环境</li><li>接着是核心的上下文部分,分为prepareContext()上下文的前置处理,refreshContext()核心方法,就是spring中的refresh()方法,其中的beanFactoryPostProcessor()完成自动装配的核心,afterRefresh()上下文后置结束处理</li><li>之后就是发布应用上下文启动,执行runner()运行器</li><li>发布应用上下文就绪并返回</li><li>SpringApplication启动结束</li></ul></li></ul><h3 id="2-run-方法解析"><a href="#2-run-方法解析" class="headerlink" title="2.run()方法解析"></a>2.run()方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//设置启动时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="comment">//设置上下文</span></span><br><span class="line">        <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext();</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//创建监听器并从中获取符合监听事件的几个监听器</span></span><br><span class="line">        <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line">        listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//配置命令行参数</span></span><br><span class="line">            <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">            <span class="comment">//准备应用程序运行的环境</span></span><br><span class="line">            <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">            <span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">//打印banner(也就是那个p用没有的图标)</span></span><br><span class="line">            <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br><span class="line">            context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">            context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line">            <span class="comment">//prepareContext和refreshContext是自动装配的核心方法 而且这个refreshContext方法就是spring中的refresh()方法 使用的就是里面的beanFactoryPostProcessor()来实现的自动装配</span></span><br><span class="line">            <span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="built_in">this</span>.refreshContext(context);</span><br><span class="line">            <span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">            <span class="comment">//发布应用上下文启动,执行runner()运行器</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            listeners.started(context, timeTakenToStartup);</span><br><span class="line">            <span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var12, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var12);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发布应用上下文就绪并返回</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">            listeners.ready(context, timeTakenToReady);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var11);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-1prepareContext（）和refreshContext（）"><a href="#2-1prepareContext（）和refreshContext（）" class="headerlink" title="2.1prepareContext（）和refreshContext（）"></a>2.1prepareContext（）和refreshContext（）</h4><h4 id="完成自动装配的核心"><a href="#完成自动装配的核心" class="headerlink" title=" 完成自动装配的核心"></a><code> 完成自动装配的核心</code></h4><p>(1)prepareContext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上下文操作的初始化，包括属性值的设置</span></span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">bootstrapContext.close(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">   logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">   logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">   beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractAutowireCapableBeanFactory) &#123;</span><br><span class="line">   ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">      ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">            .setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">   context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">&#125;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">PropertySourceOrderingBeanFactoryPostProcessor</span>(context));</span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line"><span class="comment">//在此过程中最重要的方法load()，主要完成主要完成将当前启动类作为一个beanDefinition注册到registry(注册表)中,方便后续进行BeanFactoryPostProcesser调用执行的时候,找到对应的主类,来完成对@SpringBootApplication,@EnableAutoConfiguration等注解的解析工作(注意:要完成这些注解的解析工作,必须要获取到启动类)</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br></pre></td></tr></table></figure><p>(2)refreshContext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">      shutdownHook.registerApplicationContext(context);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//主要是调用refresh方法</span></span><br><span class="line">   refresh(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在refreshContext()方法中,会调用spring中的refresh()方法(refresh()方法一共有13个非常关键的方法来完成整个spring应用程序的启动),在自动装配中会调用invokeBeanFactoryPostProcessor()方法,在此方法中主要是对ConfigurationClassPathPostProcessor类的处理(它是BeanFactoryPostProcessor的子类,也是BeanDefinitionReaderPostProcessor的子类).在调用的时候会先调用BeanDefinitionReaderPostProcessor中的postProcessorBeanDefinitionRegistry方法,然后调用PostProcessBeanFactory()方法,在执行postProcessorBeanDefinitionRegistry方法的时候会解析处理各种注解,最主要的是对@Import注解的解析</p><h3 id="3-自动装配的原理"><a href="#3-自动装配的原理" class="headerlink" title="3.自动装配的原理"></a>3.自动装配的原理</h3><p><code> 自动装配的实现就是为了从spring.factories文件中获取到对应的bean对象,并且由spring容器帮我们进行管理</code></p><ul><li><p>当启动SpringBoot应用程序的时候会先创建SpringApplication对象,在对象的构造方法中进行参数的初始化工作,最主要的是判断当前应用程序的类型以及初始化器和监听器,在此过程中会加载整个应用程序中的spring.factories文件,将文件的内容放在缓存对象中,方便后续获取</p></li><li><p>SpringBoot对象创建完成之后,开始执行run()方法来完成整个启动过程.启动过程中主要包括的两个方法:prepareContext()和refreshContext()方法,在这两个关键的步骤中完成自动装配的核心功能</p></li><li><p>在prepareContext()方法中主要完成的是对上下文对象的初始化操作,包括属性值的设置,在整个过程中最重要的方法是load(),主要完成将当前启动类作为一个beanDefinition注册到registry(注册表)中,方便后续进行BeanFactoryPostProcesser调用执行的时候,找到对应的主类,来完成对@SpringBootApplication,@EnableAutoConfiguration等注解的解析工作(注意:要完成这些注解的解析工作,必须要获取到启动类)</p></li><li><p>在refreshContext()方法中,会调用spring中的refresh()方法(refresh()方法一共有13个非常关键的方法来完成整个spring应用程序的启动),在自动装配中会调用invokeBeanFactoryPostProcessor()方法,在此方法中主要是对ConfigurationClassPathPostProcessor类的处理(它是BeanFactoryPostProcessor的子类,也是BeanDefinitionReaderPostProcessor的子类).在调用的时候会先调用BeanDefinitionReaderPostProcessor中的postProcessorBeanDefinitionRegistry方法,然后调用PostProcessBeanFactory()方法,在执行postProcessorBeanDefinitionRegistry方法的时候会解析处理各种注解,最主要的是对@Import注解的解析</p></li><li><p>在解析@Impo注解的时候,会有一个getInstance()方法,从主类中递归解析注解,把所有@Import的注解都解析到,然后在processImport()方法中对Import的类进行分类,此处主要识别的是@Import(AutoConfigurationImportSelect.class)中的AutoConfigurationImportSelect,在后续的过程中调用deferredImportSelectorHandler()中的方法来完成EnableAutoConfiguration对象的加载,之后获取到spring.factories找到大量的自动装配的类(并不是所有的类都会用到),将不适用的装配类移除,过滤掉多余的装配类(starter的作用就是确定那些配置类是需要的,哪些是不需要的)</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/4d363a67cf594463b4b8dd9707448f07.png" alt="在这里插入图片描述"></p></li></ul><h3 id="Springboot整合Jdbc和Mybatis"><a href="#Springboot整合Jdbc和Mybatis" class="headerlink" title="Springboot整合Jdbc和Mybatis"></a>Springboot整合Jdbc和Mybatis</h3><h3 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1.JDBC"></a>1.JDBC</h3><p><strong>SpringData简介</strong></p><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p><p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p><p>Sping Data 官网：<a href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p><p>数据库相关的启动器 ：可以参考官方文档：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/6946e7c8a8312108a680503ece66763a.png" alt="image-20220107105803533"></p><p><strong>参数</strong></p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221025092718591.png" alt="image-20221025092718591" style="zoom:80%;" /><p>**写配置JDBC文件，application.yaml **</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yu0804</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot04date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBoot04DateApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">            <span class="comment">//注入数据</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//查看默认的数据源</span></span><br><span class="line">        System.out.println(dataSource.getClass());<span class="comment">//class com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        <span class="comment">//Template</span></span><br><span class="line">        <span class="comment">//CURD豆子SpringBoot中封装好了，拿来即用</span></span><br><span class="line"></span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p><p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p><p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p><p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p><p><strong>JDBCTemplate</strong></p><ol><li><p>有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p></li><li><p>即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p></li><li><p>数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p></li><li><p>Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p></li><li><p>JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p></li></ol><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li><li>query方法及queryForXXX方法：用于执行查询相关语句；</li><li>call方法：用于执行存储过程、函数相关语句。</li></ul><p><strong>测试CRUD</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.Mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.test.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;select * from mybatis.user&quot;</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list_map = jdbcTemplate.queryForList(sql);</span><br><span class="line">        System.out.println(list_map);</span><br><span class="line">        <span class="keyword">return</span> list_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;insert into mybatis.user(id,name,pwd) values (7,&#x27;777&#x27;,&#x27;777&#x27;)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addUer OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/updateUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">()</span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;update mybatis.user set name=&#x27;张三&#x27;,pwd=&#x27;1111&#x27; where id=7&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;updateUser OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/deleteUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">        String sql=<span class="string">&quot;delete from mybatis.user where id=7&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;deleteUser OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-集成Druid"><a href="#2-集成Druid" class="headerlink" title="2.集成Druid"></a>2.集成Druid</h3><p><strong>Druid简介</strong></p><ul><li><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p></li><li><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p></li><li><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p></li><li><p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p></li><li><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p></li></ul><p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p><p>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</p><p><strong>参数详解</strong></p><p><a href="https://blog.csdn.net/yzh_1346983557/article/details/88547234?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-8-88547234.pc_agg_new_rank&utm_term=druiddatasource%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3&spm=1000.2123.3001.4430">DruidDataSource的使用、配置</a></p><p><a href="https://mp.weixin.qq.com/s/wVAGOP1JdXZi5DMEsX1Aug">https://mp.weixin.qq.com/s/wVAGOP1JdXZi5DMEsX1Aug</a></p><p><strong>配置数据源</strong></p><p>1、添加上 Druid 数据源依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、去配置Druid，配置自定义的数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yu0804</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="comment">#配置数据源，如：c3p0、druid、dbcp、proxool等等。通过type配置</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、接下来就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span></span><br><span class="line">   <span class="comment">#druid 数据源专有配置</span></span><br><span class="line">   <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">   <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">   <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">   <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">   <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">   <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">   <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">   <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">#  这是Druid特有的很牛逼的功能：</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span></span><br><span class="line">   <span class="comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span></span><br><span class="line">   <span class="comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span></span><br><span class="line">   <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">   <span class="comment">#  注意：filters: stat,wall,log4j  会报log4j错======因为在springboot使用的是log4j2，找不到log4j(网上查的，不知道是不是真的)</span></span><br><span class="line">   <span class="comment">#  后面发现其实是我导错log4j的包了======正确：Apache Log4j   错误：Apache Log4j Core</span></span><br><span class="line">   <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">   <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure><p>4、因为Druid中包含log4j所以需要导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="comment">//绑定到application.xml文件中 生效</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDateSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、Druid具有看监控功能，可以方便用户在web端看见后台的操作，配置后台监控和过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot04date.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="comment">//绑定到application.xml文件中 生效</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDateSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为iSpringBoot内置了servlet容器，所有没有web.xml,替代方法、：ServletRegistrationBean</span></span><br><span class="line">    <span class="comment">//后台监控功能</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">statViewServlet</span><span class="params">()</span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">StatViewServlet</span>(), <span class="string">&quot;/druid/*&quot;</span>);<span class="comment">//访问这个就可以进入后台监控页面，写死的</span></span><br><span class="line">        <span class="comment">//后台需要有人登录</span></span><br><span class="line">        <span class="comment">//账号密码配置也是死的</span></span><br><span class="line">        HashMap&lt;String,String&gt; initParameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//增加配置</span></span><br><span class="line">        initParameters.put(<span class="string">&quot;loginUsername&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        initParameters.put(<span class="string">&quot;loginPassword&quot;</span>,<span class="string">&quot;123456&quot;</span>);<span class="comment">//key是固定的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//允许谁能访问</span></span><br><span class="line">        initParameters.put(<span class="string">&quot;allow&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParameters);<span class="comment">//设置初始化参数</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter后台过滤</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">webServletFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> <span class="title class_">WebStatFilter</span>());</span><br><span class="line">        <span class="comment">//可以过滤哪些请求</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;exclusions&quot;</span>,<span class="string">&quot;*.js,*.css,/druid/*&quot;</span>);<span class="comment">//这些东西不进行统计</span></span><br><span class="line">        bean.setInitParameters(map);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-整合Mybatis"><a href="#3-整合Mybatis" class="headerlink" title="3.整合Mybatis"></a>3.整合Mybatis</h3><p>官方文档：<a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><p>Maven仓库地址：Maven Repository: org.mybatis.spring.boot » mybatis-spring-boot-starter » 2.1.3 (mvnrepository.com)</p><p><strong>测试</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>连接数据库(操作如1，省略)</p></li><li><p>导入lombok</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个实体类既需要具有增删改查的功能又需要注册到spring中托管所有需要Repository和mapper</span></span><br><span class="line"><span class="meta">@Mapper</span><span class="comment">//Dao层</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">//这个注解代表了这是一个mybatis的mapper接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">SelectAllUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">SelectUserById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写mapper.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.test.Mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;SelectAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;SelectUserById&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>  <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>绑定mapper.xml</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#整合Mybatis</span></span><br><span class="line"><span class="comment">#让spring识别到mapper文件</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.test.pojo    #这里绑定的是实体类</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mybatis/UserMapper/*.xml     #Resource资源下的Mapper文件夹的UserMapper文件</span></span><br></pre></td></tr></table></figure></li></ol><p>  8.编写Controller类测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.Mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.test.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整合mybatis</span></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/SelectAllUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">SelectAllUser</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.SelectAllUser();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/SelectUserById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">SelectUserById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.SelectUserById(<span class="number">4</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p><a href="https://mp.weixin.qq.com/s/FLdC-24_pP8l5D-i7kEwcg">https://mp.weixin.qq.com/s/FLdC-24_pP8l5D-i7kEwcg</a></p><p>shiro、SpringSecurity：很像，除了类不一样</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><ul><li><p>SpringSecurity是Springboot底层安全模块默认的技术选型，它可以实现强大的Web安全机制，只需要少数的spring-boot–spring-security依赖，进行少量的配置，就可以实现</p></li><li><p>SpringBoot中的SpringSecurity依赖：</p></li><li><p>功能权限、访问权限、菜单权限…，我们使用过滤器，拦截器需要写大量的原生代码，这样很不方便</p></li><li><p>所以在网址设计之初，就应该考虑到权限验证的安全问题，其中Shiro、SpringSecurity使用很多</p></li></ul><h3 id="2-导入依赖"><a href="#2-导入依赖" class="headerlink" title="2.导入依赖"></a>2.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>记住几个类 ：</p><ul><li>WebSecurityConfigurerAdapter:自定义Security策略</li><li>AuthenticationManagerBuilder:自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><p>两个单词：en是认证，or是权限</p><ul><li>认证方式：Authentication</li><li>权限：Authorization</li></ul><p>注意：在后续springboot中，我们经常看见<code>Enable××× </code>这是开启某个功能</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221025221116345.png" alt="image-20221025221116345"></p><h3 id="3-配置SecurityConfigure"><a href="#3-配置SecurityConfigure" class="headerlink" title="3.配置SecurityConfigure"></a>3.配置SecurityConfigure</h3><p>在MyConfigure中新建SecurityConfigure类，此类继承WebSecurityConfigurerAdapter ，并重载一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重载<code> configure</code>方法&#x3D;&#x3D;&#x3D;&gt;注意：是configure(HttpSecurity http)和configure(AuthenticationManagerBuilder auth)   参数不同，功能不同。</p><h3 id="4-授权和认证"><a href="#4-授权和认证" class="headerlink" title="4.授权和认证"></a>4.授权和认证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfigure</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//首页所有人可以访问，但是功能页只有对应有权限的人才能访问</span></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        <span class="comment">//请求授权的规则</span></span><br><span class="line">        http.authorizeHttpRequests().antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()<span class="comment">//允许所有人访问主页</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)<span class="comment">//设置level1下的页面只有vip1权限才能访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有权限默认为登录页</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="comment">//密码编码  PasswordEncoder</span></span><br><span class="line">    <span class="comment">//在SpringSecuritys5中,新增了许多加密方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//这些数据应该从数据库中读</span></span><br><span class="line">        auth.inMemoryAuthentication()<span class="comment">//inMemory：从缓存中取</span></span><br><span class="line">            .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>())</span><br><span class="line">            .withUser(<span class="string">&quot;root&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>().encode(<span class="string">&quot;11111&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="string">&quot;yu&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>().encode(<span class="string">&quot;11111&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>);</span><br><span class="line">        <span class="comment">//将登录写入缓存，设置不同用户有不同的访问权限</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写一个类继承WebSecurityConfigurerAdapter，使用@EnableWebSecurity开启web安全服务</p><ul><li>地址授权：使用HttpSecurity security</li><li>账户认证和给予权限：使用AuthenticationManagerBuilder builder</li><li>SpringSecurity5 以后默认需要密码加密方式，推荐使用passwordEncoder(new BCryptPasswordEncoder())</li></ul><h3 id="5-注销以及控制权限"><a href="#5-注销以及控制权限" class="headerlink" title="5.注销以及控制权限"></a>5.注销以及控制权限</h3><ul><li>定制登录<ul><li>开启登录功能：formLogin()，Springboot默认自带一个登录页&#x2F;login定制看下面</li></ul></li><li>注销<ul><li>springboot自带注销页：<code>/logout</code></li><li>注销成功后跳转到&#x2F;控制器</li></ul></li><li>记住我<ul><li>本质就是存一个cookies，默认保存2周</li></ul></li></ul><p><strong>这些操作都是在授权里做</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfigure</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//首页所有人可以访问，但是功能页只有对应有权限的人才能访问</span></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        <span class="comment">//请求授权的规则</span></span><br><span class="line">        http.authorizeHttpRequests().antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()<span class="comment">//允许所有人访问主页</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)<span class="comment">//设置level1下的页面只有vip1权限才能访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有权限默认为登录页</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>);<span class="comment">//退出登录后跳到主(首)页</span></span><br><span class="line">        <span class="comment">//自定义</span></span><br><span class="line">        <span class="comment">// 开启记住我功能:本质就是记住一个cookies，默认保存2周</span></span><br><span class="line">        <span class="comment">//http.rememberMe().rememberMeParameter(&quot;remember&quot;);</span></span><br><span class="line">        http.rememberMe();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>现在提出一个需求：我们希望拥有不同权限的用户登录后只能看见属于当前用户权限的功能（页面），以及用户未登录前只显示登录（将注销隐藏），用户登录后显示注销和用户的名字，将登录隐藏</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221025232627264.png" alt="image-20221025232627264"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221025232637394.png" alt="image-20221025232637394"></p><p>思路：通过thymeleaf和SpringSecurity整合可以实现（也可以使用jsp与SpringSecurity整合）</p><p>1、导入依赖</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221026150725875.png" alt="image-20221026150725875"></p><p>导入最新3.1.× 会报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、在html中导入支持</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:sec=“http://www.thymeleaf.org/thymeleaf-extras-springsecurity5”</span><br></pre></td></tr></table></figure><p>3、编写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;!isAuthenticated()&quot;</span>&gt;</span> 未登录显示</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span> 以登陆显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在我们测试时发现：点击注销时会报404错误！这时，我们会怀疑是不是代码写错了，，，其实是因为浏览器它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p><p><img src="/../../../../../15864/roaming/Typora/typora-user-images/image-20221026153922806.png" alt="image-20221026153922806"></p><p>测试一下：ok !</p><h3 id="6-记住我"><a href="#6-记住我" class="headerlink" title="6.记住我"></a>6.记住我</h3><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p><p>1、开启记住我功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定制请求的授权规则</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//。。。。。。。。。。。</span></span><br><span class="line">   <span class="comment">//记住我</span></span><br><span class="line">   http.rememberMe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p><p>勾选“记住我”后，当我们退出浏览器，下次再次访问网页时会保持登录状态</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221026154218502.png" alt="image-20221026154218502"></p><p>思考：如何实现的呢？其实非常简单</p><p>我们可以查看浏览器的cookie</p><p><img src="/Springboot%E5%85%A5%E9%97%A8/20230406133331-1680759262107-5.png"></p><p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p><p><img src="/Springboot%E5%85%A5%E9%97%A8/20230406133433.png" alt="图片"></p><p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p><h3 id="7-定制登录页"><a href="#7-定制登录页" class="headerlink" title="7.定制登录页"></a>7.定制登录页</h3><p>当我们未登录点击受到保护的网页时，会自动跳转到spring security默认的登录页，若我们想实现自动跳转到我们自己的登录页是该怎么实现？？</p><p>1、在刚才的登录页配置后面指定 loginpage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin().loginPage(<span class="string">&quot;/toLogin&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、然后前端也需要指向我们自己定义的 login请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=<span class="string">&quot;item&quot;</span> th:href=<span class="string">&quot;@&#123;/toLogin&#125;&quot;</span>&gt;</span><br><span class="line">   &lt;i class=<span class="string">&quot;address card icon&quot;</span>&gt;&lt;/i&gt; 登录</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为<strong>post:</strong></p><p>在 loginPage()源码中的注释上有写明：</p><p><img src="/Springboot%E5%85%A5%E9%97%A8/20230406133507.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form th:action=<span class="string">&quot;@&#123;/login&#125;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">   &lt;div class=<span class="string">&quot;field&quot;</span>&gt;</span><br><span class="line">       &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">       &lt;div class=<span class="string">&quot;ui left icon input&quot;</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;Username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">           &lt;i class=<span class="string">&quot;user icon&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;div class=<span class="string">&quot;field&quot;</span>&gt;</span><br><span class="line">       &lt;label&gt;Password&lt;/label&gt;</span><br><span class="line">       &lt;div class=<span class="string">&quot;ui left icon input&quot;</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">           &lt;i class=<span class="string">&quot;lock icon&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;submit&quot;</span> class=<span class="string">&quot;ui blue submit button&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">  .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">  .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">  .loginPage(<span class="string">&quot;/toLogin&quot;</span>)</span><br><span class="line">  .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 登陆表单提交请求</span></span><br></pre></td></tr></table></figure><p>5、在登录页增加记住我的多选框</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;remember&quot;</span>&gt; 记住我</span><br></pre></td></tr></table></figure><p>6、后端验证处理！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定制记住我的参数！</span></span><br><span class="line">http.rememberMe().rememberMeParameter(<span class="string">&quot;remember&quot;</span>);</span><br></pre></td></tr></table></figure><p>7、测试，OK</p><p>​</p><h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><h3 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h3>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境下使用MongoDB</title>
      <link href="/2023/03/31/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8MongoDB/"/>
      <url>/2023/03/31/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux环境下使用MongoDB"><a href="#Linux环境下使用MongoDB" class="headerlink" title="Linux环境下使用MongoDB"></a>Linux环境下使用MongoDB</h2><p>安装：官网下载linux版本mogodb……(教程网上有，此处省略)</p><h3 id="1、新建用户"><a href="#1、新建用户" class="headerlink" title="1、新建用户"></a>1、新建用户</h3><p>由于root用户拥有的权限很大，处于系统的安全考虑，需要新建一个普通用户操作MongoDB数据库（user_mongo)</p><h4 id="1、新建用户-1"><a href="#1、新建用户-1" class="headerlink" title="1、新建用户"></a>1、新建用户</h4><p>命令：</p><ul><li>useradd user_mongo</li><li>passwd user_mongo</li></ul><p>这是需要输入密码，出现successfully 即添加用户成功</p><h4 id="2、用户授权"><a href="#2、用户授权" class="headerlink" title="2、用户授权"></a>2、用户授权</h4><p>（1）使用  <code> ls -l /etc/sudoers</code>命令，查看文件sudoers的操作权限</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102091439900.png" alt="image-20221102091439900"></p><p>​可以知道，文件sudoers的操作权限只为可读，不可进行编辑操作</p><p>（2）在root权限下使用命令：<code>chmod -c u+w /etc/sudoers</code>  将文件sudoers的权限更改为可编辑，然后使用 <code> ls -l /etc/sudoers</code> 命令，查看文件sudoers的权限是否变为可编辑，具体如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102091940920.png" alt="image-20221102091940920"></p><p>(3) 执行<code> vi /etc/sudoers</code> 命令，进入sudoers文件中，添加user_mongo ALL&#x3D;(ALL)ALL内容，安<code> Esc</code> 键，再执行：<code>wq!</code> 命令，保存并退出。添加内容如下：(vi&#x2F;vim操作 ：i 命令编辑；Esc 退出编辑；<code> ctrl+;</code>用于输入命令行。wq:保存并退出。</p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102092753191.png" alt="image-20221102092753191" style="zoom: 50%;" /><p>（4）为了系统安全，编辑完sudoers文件后，必须执行<code>chmod -v u-w /etc/sudoers</code>将该文件的权限更改为只读权限。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102093401525.png" alt="image-20221102093401525"></p><p>（5）切换用户<code>su user_mongo</code></p><h3 id="2、上传文件"><a href="#2、上传文件" class="headerlink" title="2、上传文件"></a>2、上传文件</h3><p>通过xShell上传文件到Linux</p><p>(1)在Linux终端使用命令<code> ifconfig</code>查看ip</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102101622068.png" alt="image-20221102101622068"></p><p>(2)打开xShell，输入ip新建连接</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102101711727.png" alt="image-20221102101711727"></p><p>确认后会弹出输入框，选择角色进行登录，出现如下即连接成功</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102101808734.png" alt="image-20221102101808734"></p><p>(3)将文件拖到上图即可实现文件上传</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102102309473.png" alt="image-20221102102309473"></p><p>这里出现问题，上传到如下目录上传会失败。可能是权限不够吧</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102102341551.png" alt="image-20221102102341551"></p><h3 id="3、解压安装"><a href="#3、解压安装" class="headerlink" title="3、解压安装"></a>3、解压安装</h3><p>（1）创建mongoDB文件夹用于存放解压文件</p><p>（2）tar 命令解压</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102103304839.png" alt="image-20221102103304839"></p><p>(3)解压完安装包后进入到mongoDB，发现文件名太长，可以对文件名重定义。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102103530115.png" alt="image-20221102103530115"></p><h3 id="4、配置MongoDB"><a href="#4、配置MongoDB" class="headerlink" title="4、配置MongoDB"></a>4、配置MongoDB</h3><p>（1）通常情况下，MongoDB的数据文件会放在data目录的db目录下，日志文件放在logs目录下，但是这两个目录以解压缩方式安装时不会自动创建。因此需要我们在mongodb下手动创建data目录和logs目录，并在data目录中创建db目录，在logs目录下创建mongolog.log日志文件，具体命令如下：</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102104408418.png" alt="image-20221102104408418"></p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102104419462.png" alt="image-20221102104419462"></p><p>（2）为避免用户直接进入bin目录下启动MongoDB的相关服务配置，我们需要配置用户环境变量。命令如下<code> vi ~/.bash_profile</code>，添加如下内容。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102105020607.png" alt="image-20221102105020607"></p><p>（3）然后执行<code> source ~/.bash_profile</code>，使修改后的.&#x2F;bash_profile文件生效。注意：每次切换成user_mongo用户后，都需要执行<code>source ~/.bash_profile</code>命令初始化用户环境变量。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221102105348956.png" alt="image-20221102105348956"></p><p>（4）启动MongoDB服务</p><p>两种方式：</p><p>a.使用命令行参数方式启动MongoDB服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$mongod --dbpath=/mongoDB/mongodb/data/db</span><br><span class="line">--logpath=/mongoDB/mongodb/logs/mongolog.log</span><br><span class="line">--logappend -fork</span><br></pre></td></tr></table></figure><p>​mongod：是MongoDB服务</p><p>​–dbpath：指定数据文件存放的位置</p><p>​–logpath：指定日志文件存放位置</p><p>​–logappend：指定使用追加的方式写日志</p><p>​–fork：指定以守护进程（后台）的方式运行MongoDB服务</p><p>b.使用配置文件的方式启动MongoDB服务</p><p>​    在mongodb目录下创建conf文件，用于存放MongoDB数据库的配置文件，并在conf文件下创建mongod.conf文件，用来指定MongoDB服务启动所需的一些参数。</p><p><img src="https://yuydot-image-host.oss-cn-beijing.aliyuncs.com/img/image-20221115173550105.png" alt="image-20221115173550105"></p><p>在mongodb目录下执行<code>vi conf/mongod.conf</code>命令，打开并编辑mongod.conf文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
